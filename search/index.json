[{"content":"SMU医工融合团队（实验室）介绍 实验室概述 SMU医工融合团队致力于跨学科的研究，特别是在医学与工程学的结合方面。团队的主要研究方向包括医疗影像处理、人工智能在医学中的应用、脑科学及神经网络建模等。我们通过多模态数据的深度学习分析，为临床提供更为精准的诊断工具，并推动医学和技术的融合发展。\n团队老师介绍（部分） 我们的团队成员来自数学、计算机科学等多个学科领域，具有丰富的研究经验和多项学术成果。\n负责人：谭颖 男，博士，教授，数学学院院长，哈佛大学博士后、电子科技大学博士后。硕士生导师，国家民委重点实验室-西南民族大学计算机系统实验室主任。\nhttps://sxxy.swun.edu.cn/info/1077/1775.htm （数学学院官网介绍） https://jkxy.swun.edu.cn/info/1206/3904.htm （计算机与人工智能学院官网介绍）\n成员：苗加庆 电子科技大学，数学科学学院，获理学博士学位，西南民族大学，数学学院副教授。\nhttps://sxxy.swun.edu.cn/info/1077/1772.htm （数学学院官网介绍）\n成员：陈洪瀚 工学博士，讲师, 西南交通大学，计算机应用技术专业；中科院宁波材料所/博后。\nhttps://jkxy.swun.edu.cn/info/1076/3858.htm （计算机与人工智能学院官网介绍）\n成员：梁平 2002年获得英国约克大学软件工程硕士学位，2017获得泰国孔敬大学计算机科学博士学位，副高级，担任软件工程学硕及计算机技术专硕导师。\nhttps://jkxy.swun.edu.cn/info/1076/2898.htm （计算机与人工智能学院官网介绍）\n实验室本科负责人（部分） 仅包含已毕业学长学姐\n2018级负责人 朱亚飞，2018级计算机科学与技术（大数据方向）专业本科生，连续三年专业成绩排名专业第一，发表SCI期刊论文一篇，现以直博生推免至北京大学前沿交叉学科研究院。\nhttps://mp.weixin.qq.com/s/kCdGELSscnG-Wj8nQJMlkA （西南民族大学官方微信公众号）\n2019级负责人 祝佳怡，2019级计算机科学与技术专业本科生，平均绩点3.97，所修70门课程中65门课程获得满绩，推免排名第一，直博北京师范大学昌平国家实验室，认知神经科学专业。\nhttps://mp.weixin.qq.com/s/ZRH6zKeeIsNnGjkJQ4f6nw （西南民族大学计算机学院官方微信公众号）\n2020级负责人 吴东涵，2020级计算机科学与技术专业本科生，荣获两次国家奖学金、计科专业综合成绩全年级第一，现以直博生推免至中国科学院宁波材料所。\nhttps://mp.weixin.qq.com/s/HfGU8VKWyfrfezW7MbVyIQ （西南民族大学计算机学院官方微信公众号）\n2021级负责人 朱宗信，2021级负责人计算机科学与技术专业本科生，计科专业综合成绩全年级第二，现以直博生推免至南京理工大学计算机专业。\nhttps://mp.weixin.qq.com/s/egznDmcVOVIk-smhSr2q5w （西南民族大学计算机学院官方微信公众号）\n研究成果 科研论文（部分）\n（1）Zhu Cheng#, Tan Ying*, Yang Shuqi#, Miao Jiaqing*, Zhu Jiayi, Huang Huan, Yao Dezhong, Luo Cheng*. Temporal Dynamic Synchronous Functional Brain Network for Schizophrenia Classification and Lateralization Analysis [J].IEEE Transactions on Medical Imaging, 2024.\n（2）Yang Shuqi, Lan Qing, Zhang Lijuan, Zhang Kuangling, Tang Guangmin, Huang Huan, Liang Ping, Miao Jiaqing, Zhang Boxun, Tan Rui, Yao Dezhong, Luo Cheng*, and Tan Ying*. Multimodal cross-scale context clusters for classification of mental disorders using functional and structural MRI, Neural Networks, 2025, 185: 107209.\n（3）Yang Shuqi, Zhang Lijuan, Lan Qing, Ma Qiujie, Huang Huan, Miao Jiaqing, Mou Shiyu, Luo Cheng, Yao Dezhong, Tan Ying*. NeuroSparse: An Unsupervised Framework for Inferring Brain Connectivity in Autism Diagnosis[C]. Proceedings of the 2024 IEEE International Conference on Bioinformatics and Biomedicine (BIBM), F, 2024 .\n（4）Ma Qiujie, Yang Shuqi, Zhang Lijuan, Lan Qing, Yang Dongdong, Chen Honghan, Tan Ying*. APOVIS: Automated pixel-level open-vocabulary instance segmentation through integration of pre-trained vision-language models and foundational segmentation models [J]. Image and Vision Computing, 2025, 154.\n（5）Wu Donghan, Yang Shuyuan, Wang Zhichang, Yang Shuqi, Liang Ping, Zhang Boxun, Li Yi, Miao Jiaqing, Tan Ying*. SCANet: Dual Attention Network for Alzheimer’s Disease Diagnosis Based on Gated Residual and Spatial Asymmetry Mechanisms [C]; Proceedings of the 33rd International Conference on Artificial Neural Networks, ICANN 2024, September 17, 2024 - September 20, 2024, Lugano, Switzerland, F, 2024. Springer Science and Business Media Deutschland GmbH.\n指导学科竞赛获奖情况（部分）\n（1）吴东涵、朱宗信、王志昌、杨淑媛等；《基于注意力微设计 EfficientNetB2 诊断阿尔茨海默症》； 第十七届“挑战杯”大学生课外学术科技作品，四川省一等奖；2023年；指导教师：谭颖，校景中\n（2）祝佳怡、吴东涵、范旭伟.《记忆守护站\u0026ndash;阿尔茨海默病智能医疗辅助诊断系统》；第15届中国大学生计算机设计大赛，四川省二等奖；2022年；指导教师：谭颖\n（3）祝佳怡、刁颖颖、王程、吴东涵等. 《记忆守护站\u0026ndash;云上的阿尔兹海默症辅助诊断专家》；第八届国际“互联网+”，四川省银奖；2022年；指导教师：谭颖，校景中等\n（4）付舒悦、曾嫣嵘、杨仕虎等. 《AI-Brains一用脑科学打开精神分裂诊断新大门》；第六届国际“互联网+”，四川省铜奖；2020年；指导教师：谭颖，校景中\n（5）付舒悦、朱亚飞、杨仕虎等.《基于磁共振技术对精神分裂症的智能辅助诊断系统》，“挑战杯”大学生创业计划竞赛，四川省铜奖；2020年；指导教师：谭颖\n（6）朱亚飞、祝佳怡、林儒德等. 《Al-Brains\u0026ndash;用深度学习打开精神分裂症诊断新大门》；第十六届“挑战杯”大学生课外学术科技作品，四川省三等奖；2021年；指导教师：谭颖，校景中\n欢迎对我们研究方向感兴趣的大一、大二的学生联系我们。我们的团队非常欢迎各类跨学科合作，共同推动AI+医学的深度融合。 ","date":"2025-09-15T11:22:19+08:00","permalink":"https://IsQinna.github.io/p/the-smu-med-engineering-fusion-group/","title":"The SMU Med-Engineering Fusion Group"},{"content":"A Prepend and Append 题目给出一个01字符串，字符串可以进行有限次将01或者10添加到头和尾的操作，要求找出最短的初始字符串。 解析：只能头尾各增加一个互异的01字符，因此如果碰到相同的字符，即为最短字符。 注意：当n为1的时候，l和r左移右移，就交叉了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=1e6; int main() { int _; //\t_=1; cin\u0026gt;\u0026gt;_; while(_--){ string s; int n; cin\u0026gt;\u0026gt;n; cin\u0026gt;\u0026gt;s; int minsize=0; if(n==1){ cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; continue; } for(int l=0,r=n-1;l\u0026lt;r;){ if(s[l]!=s[r]){ l++; r--; } if(s[l]==s[r]) { minsize=(r-l)+1; break;\t} } cout\u0026lt;\u0026lt;minsize\u0026lt;\u0026lt;endl;\t} } B Distinct Split 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=30; int l[N],r[N]; int main() { int _; cin\u0026gt;\u0026gt;_; while(_--){ for(int i=0;i\u0026lt;26;i++){ r[i]=0; l[i]=0; }\tint n; cin\u0026gt;\u0026gt;n;\tstring s; cin\u0026gt;\u0026gt;s; //假设全在右边 for(int i=0;i\u0026lt;n;i++){ r[s[i]-\u0026#39;a\u0026#39;]++; }\tint ans=0; //统计不同字母 for(int i=0;i\u0026lt;26;i++){ if(r[i]\u0026gt;0){ ans++; } }\t//切割1~n-1 int maxnum=0; for(int i=0;i\u0026lt;n-1;i++){ int t=s[i]-\u0026#39;a\u0026#39;; l[t]++; r[t]--; if(r[t]==0) ans--; if(l[t]==1) ans++; maxnum=max(maxnum,ans); } cout\u0026lt;\u0026lt;maxnum\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-02-22T11:24:19+08:00","permalink":"https://IsQinna.github.io/p/smu-spring-2023-trial-contest-round-1%E8%A1%A5%E9%A2%98/","title":"SMU Spring 2023 Trial Contest Round 1补题"},{"content":"Day1 寒假每日一题 1.总伤害超过其防御力，那么这个战舰会爆炸 2.第一艘爆炸的战舰是在哪一轮攻击后爆炸的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e6; int d[N]; int la[N],ra[N],lb[N],rb[N],lc[N],rc[N],h[N]; int main() { int a,b,c,m; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c\u0026gt;\u0026gt;m; //立方体 for(int i=1;i\u0026lt;=a;i++){//层 for(int j=1;j\u0026lt;=b;j++){//行 for(int k=1;k\u0026lt;=c;k++)//列 { int sum=((i-1)*b+(j-1))*c+(k-1)+1; cin\u0026gt;\u0026gt;d[sum]; } } } /* sum=0; cout\u0026lt;\u0026lt;\u0026#34;-----------\u0026#34;\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=a;i++){//层 for(int j=1;j\u0026lt;=b;j++){//行 for(int k=1;k\u0026lt;=c;k++)//列 { cout\u0026lt;\u0026lt;d[++sum]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } }\t} */ for(int i=1;i\u0026lt;=m;i++){ cin\u0026gt;\u0026gt;la[i]\u0026gt;\u0026gt;ra[i]\u0026gt;\u0026gt;lb[i]\u0026gt;\u0026gt;rb[i]\u0026gt;\u0026gt;lc[i]\u0026gt;\u0026gt;rc[i]\u0026gt;\u0026gt;h[i]; } for(int ans=1;ans\u0026lt;=m;ans++){ for(int i=1;i\u0026lt;=a;i++){//层 for(int j=1;j\u0026lt;=b;j++){//行 for(int k=1;k\u0026lt;=c;k++)//列 { if(i\u0026gt;=la[ans]\u0026amp;\u0026amp;i\u0026lt;=ra[ans]\u0026amp;\u0026amp;j\u0026gt;=lb[ans]\u0026amp;\u0026amp;j\u0026lt;=rb[ans]\u0026amp;\u0026amp;k\u0026gt;=lc[ans]\u0026amp;\u0026amp;k\u0026lt;=rc[ans]){ int num=((i-1)*b+(j-1))*c+(k-1)+1; d[num]-=h[ans]; //\tcout\u0026lt;\u0026lt;\u0026#34;d:\u0026#34;\u0026lt;\u0026lt;d[num]\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;num:\u0026#34;\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl; if(d[num]\u0026lt;0){ cout\u0026lt;\u0026lt;ans; return 0; } } } } } } } 寒假每日一题 [蓝桥杯 2014 省 AB] 蚂蚁感冒 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=1e5+10; vector\u0026lt;int\u0026gt;a; bool cmp(const int a,const int b){ return abs(a)\u0026lt;abs(b); } int main() { int n; cin\u0026gt;\u0026gt;n; int ganmao; for(int i=1;i\u0026lt;=n;i++){ int x; cin\u0026gt;\u0026gt;x; if(i==1) ganmao=x; a.push_back(x); }\tsort(a.begin(),a.end(),cmp); //\tfor(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;\u0026#34;a[i]\u0026#34;\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;endl; vector\u0026lt;int\u0026gt;::iterator it; it=find(a.begin(),a.end(),ganmao); int res=it-a.begin(); //\tcout\u0026lt;\u0026lt;\u0026#34;res=\u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; int sum=0; if(ganmao\u0026gt;0) { for(int i=res;i\u0026lt;n;i++) { if(a[i]\u0026lt;0) sum++; } if(sum\u0026gt;0) { for(int i=0;i\u0026lt;res;i++) { if(a[i]\u0026gt;0) sum++; } } else{ cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; return 0; } //\tcout\u0026lt;\u0026lt;\u0026#34;sum=\u0026#34;\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } else{ for(int i=0;i\u0026lt;res;i++) { if(a[i]\u0026gt;0) sum++; } if(sum\u0026gt;0){ for(int i=res;i\u0026lt;n;i++) { if(a[i]\u0026lt;0) sum++; } } else{ cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; return 0; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } } [蓝桥杯 2022 省 B] 刷题统计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main() { ll a,b,n; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;n; ll sum=0,ans=0; while(1){ for(int i=1;i\u0026lt;=7;i++){ ans++; if(i\u0026lt;=5) sum+=a; else sum+=b; if(sum\u0026gt;=n){ cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } } } } [蓝桥杯 2022 国 B] 齿轮 找到任意两对的商=qi就可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=2e5+10; //int a[N],st[N]; //bool flag[N]; int n,q,t; int st[N]; int a[N],flag[N]; //flag存当前数组中的数能构成哪些商值，作为qi int main() { scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;q); for(int i=1;i\u0026lt;=n;i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); st[t]=1; a[i]=t; } for(int i=1;i\u0026lt;=n;i++) { int up=sqrt(a[i]); for(int j=1;j\u0026lt;=up;j++) { if(a[i]%j==0) { if(st[j]) flag[a[i]/j]=1; if(st[a[i]/j]) flag[j]=1; } } } for(int i=0;i\u0026lt;q;i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); if(flag[t]) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } return 0; } 蓝桥杯 2022 省 A] 求和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=2e5+10; ll a[N]; ll s[N]; int main() { ll n; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); //求它们两两相乘再相加的和 ll sum=0; for(ll i=1;i\u0026lt;=n;i++) s[i]=s[i-1]+a[i]; for(ll i=1;i\u0026lt;n;i++) { sum+=a[i]*(s[n]-s[i]); } printf(\u0026#34;%lld\u0026#34;,sum); return 0; } [蓝桥杯 2022 省 B] 修建灌木 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=1e4+100; ll a[N]; ll amax[N]; int n; int main() { cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++) { int t=max(i-1,n-i); cout\u0026lt;\u0026lt;2*t\u0026lt;\u0026lt;endl; } return 0; } Day3 SMU Winter 2023 Round #13 (Div.2) B - BM 算日期 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=9999; bool Leap_Yaer(int year) { return ((year % 400 == 0) || (year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0)); } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--) { int y,a; cin\u0026gt;\u0026gt;y\u0026gt;\u0026gt;a; int x=y+a; //\tcout\u0026lt;\u0026lt;\u0026#34;x1=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; if(x\u0026gt;N) { x=N-(x-N); //\tcout\u0026lt;\u0026lt;\u0026#34;x=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; } if(x\u0026lt;y){ int swap=x; x=y; y=swap; } int ans=0; for(int i=y;i\u0026lt;=x;i++) { if (Leap_Yaer(i)) { ans++; }\t} cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\t} return 0; } E - BM 充饥 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { string s; cin\u0026gt;\u0026gt;s; printf(\u0026#34; __ _____\\n\u0026#34;); printf(\u0026#34;| | ___/ ____\\\\____\\n\u0026#34;); printf(\u0026#34;| |/ /\\\\ __\\\\/ ___\\\\\\n\u0026#34;); printf(\u0026#34;| \u0026lt; | | \\\\ \\\\___\\n\u0026#34;); printf(\u0026#34;|__|_ \\\\ |__| \\\\___ \u0026gt;\\n\u0026#34;); printf(\u0026#34; \\\\/ \\\\/\\n\u0026#34;); return 0; } G-New Game 要想输出唯一，要按照字典序输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e3+100; int e[N],ne[N],h[N],idx; int d[N]; int q[N],tt=-1,hh=0; //int n,m,a,b; int n,m; void add(int a,int b) { e[idx]=b,ne[idx]=h[a],h[a]=idx++; } void topsort() { for(int i=1;i\u0026lt;=n;i++){//遍历一遍顶点的入度 if(d[i]==0) q[++tt]=i;//如果入度为0，入队列 } while(tt\u0026gt;=hh)//队列不为空 { int a=q[hh++];//入队 for(int i=h[a];i!=-1;i=ne[i]) {//循环删除a发出的边 int b=e[i];//a有一条边指向b d[b]--;//删除边后，b的入度-1 if(d[b]==0) {//如果b的入度减为0，b入队列 q[++tt]=b; } } } } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--) {\tcin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; memset(h,-1,sizeof(h));//初始化邻接矩阵 while(m--) { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; d[b]++;//顶点b的入度+1 add(a,b);//添加到邻接矩阵 } topsort(); for(int i=0;i\u0026lt;n;i++) cout\u0026lt;\u0026lt;q[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } H- Hsueh- Draw Progress 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=20; typedef long long ll; int main() { int t; cin\u0026gt;\u0026gt;t; while(t--) { double n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;; for(int i=0;i\u0026lt;m;i++) cout\u0026lt;\u0026lt;\u0026#34;#\u0026#34;; for(int i=0;i\u0026lt;n-m;i++) cout\u0026lt;\u0026lt;\u0026#34;-\u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;]\u0026#34;\u0026lt;\u0026lt;\u0026#34; \u0026#34;; int sum=m/n*100; printf(\u0026#34;%d\u0026#34;,sum); cout\u0026lt;\u0026lt;\u0026#34;%\u0026#34;\u0026lt;\u0026lt;endl; } } I. BM 旅游 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=20; typedef long long ll; ll sum(int number) { int sum=0; do { sum+=number%10; number=number/10; } while (number!=0); //\tprintf(\u0026#34;%d\\n\u0026#34;,sum); return sum; } int main() { ll a,b,c,d; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c\u0026gt;\u0026gt;d; int ans=0; if(sum(a)\u0026gt;=16||sum(a)==6) { ans++; } if(sum(b)\u0026gt;=16||sum(b)==6) { ans++; } if(sum(c)\u0026gt;=16||sum(c)==6) { ans++; } if(sum(d)\u0026gt;=16||sum(d)==6) { ans++; } if(ans==4) cout\u0026lt;\u0026lt;\u0026#34;Oh my God!!!!!!!!!!!!!!!!!!!!!\u0026#34;\u0026lt;\u0026lt;endl; if(ans==3) cout\u0026lt;\u0026lt;\u0026#34;Bao Bao is a SupEr man///!\u0026#34;\u0026lt;\u0026lt;endl; if(ans==2) cout\u0026lt;\u0026lt;\u0026#34;BaoBao is good!!\u0026#34;\u0026lt;\u0026lt;endl; if(ans==1) cout\u0026lt;\u0026lt;\u0026#34;Oh dear!!\u0026#34;\u0026lt;\u0026lt;endl; if(ans==0) cout\u0026lt;\u0026lt;\u0026#34;Bao Bao is so Zhai......\u0026#34;\u0026lt;\u0026lt;endl; return 0; } J. 大扫除 用map的我真的是当时脑子有坑 应该用set\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=20; typedef long long ll; int main() { int t; cin\u0026gt;\u0026gt;t; while(t--) { int n; cin\u0026gt;\u0026gt;n; ll ans=0; while(n--) { string s; cin\u0026gt;\u0026gt;s; map\u0026lt;char,bool\u0026gt;f; for (int i=0;i\u0026lt;s.size();i++) { if(s[i]!=\u0026#39;.\u0026#39;\u0026amp;\u0026amp;f[s[i]]!=true) { //\tcout\u0026lt;\u0026lt;\u0026#34;s[i]=\u0026#34;\u0026lt;\u0026lt;s[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;\u0026#34;sum[i]=\u0026#34;\u0026lt;\u0026lt;sum[s[i]]\u0026lt;\u0026lt;endl; ans++; f[s[i]]=true; } } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } } Day5 SMU Winter 2023 Round #14 (Div.1+2) A. 解开束缚缠丝Ⅱ 1.构成的最长回文串的长度是多少\n2.分情况讨论，奇数的情况，偶数的情况\n3.分别统计每个字符出现的次数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; int n; int cnt[130]; int one = 0, ans = 0; //统计每个字母的数目。奇数有一个放中间，偶数直接放两边 LL jiejue() { cin \u0026gt;\u0026gt; n; for (int i = \u0026#39;a\u0026#39;; i \u0026lt;= \u0026#39;z\u0026#39;; ++i) { cnt[i] = 0; } for (int i = \u0026#39;A\u0026#39;; i \u0026lt;= \u0026#39;Z\u0026#39;; ++i) { cnt[i] = 0; } for (int i = 1; i \u0026lt;= n; ++i) { string x; cin \u0026gt;\u0026gt; x; cnt[x[0]]++; } one = ans = 0; for (int i = \u0026#39;A\u0026#39;; i \u0026lt;= \u0026#39;Z\u0026#39;; ++i) { if (cnt[i] % 2 != 0) { one = 1; ans += (cnt[i] - 1); } else ans += cnt[i]; } for (int i = \u0026#39;a\u0026#39;; i \u0026lt;= \u0026#39;z\u0026#39;; ++i) { if (cnt[i] % 2 != 0) { one = 1; ans += (cnt[i] - 1);//如果是一个的话就摆不好 } else ans += cnt[i]; } if(one==1){ cout \u0026lt;\u0026lt; ans +1 \u0026lt;\u0026lt; endl; } else{ cout\u0026lt;\u0026lt; ans\u0026lt;\u0026lt; endl; } } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--){ jiejue(); } } B.7的意志 1.寻找区间能相加等于7777的\n2.用前缀和算出他们的前缀和，然后判断+7777的数是否在这个前缀和中\n3.若在，找出他的最小下标\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; const LL N=1e5+10; LL s[N]; LL a[N]; //输出一个整数代表有多少个不同的区间和为7777 LL jiejue() { int n; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; s[i]=s[i-1]+a[i];//前缀和 } LL ans=0; for(int i=1;i\u0026lt;=n;i++){ LL tar = s[i - 1] + 7777;//左边 i-1 LL x = lower_bound(s + 1, s + n + 1, tar) - s;//右边x if (s[x] == tar) ++ans; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin\u0026gt;\u0026gt;t; while(t--){ jiejue(); } return 0; } I. 好想听肆宝唱歌啊 1.关键是结构体排序\n2.找到第k+1的歌曲名字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; int n; struct SONG { int w; string x; }s[100005];//结构体 bool operator\u0026lt;(const SONG \u0026amp;A, const SONG \u0026amp;B) { return A.w \u0026gt; B.w; };//自定义排序规则 void jiejue() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; s[i].w \u0026gt;\u0026gt; s[i].x; } sort(s + 1, s + n + 1); int k; cin \u0026gt;\u0026gt; k; cout \u0026lt;\u0026lt; s[k + 1].x\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); LL t; //\tcin \u0026gt;\u0026gt; _; t= 1; while (t--) jiejue(); return 0; } J. 毁灭凤凰人 1.有两种情况下能将凤凰人除外\n2.送到墓地，再使用怪兽卡\n3.没送到墓地，使用「墓穴的指名者」\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; int n, m; int mxa = 0, a = 0, b = 0; void jiejue() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;//卡牌数量，毁灭凤凰人状态，0攻击1防守 for (int i = 1; i \u0026lt;= n; ++i) { int o, x; cin \u0026gt;\u0026gt; o;//卡牌种类。0状态附带攻击值 if (o == 0) { cin \u0026gt;\u0026gt; x; mxa = max(mxa, x);//只使用攻击值最大的卡牌 } else if (o == 1) a = 1;//1状态防守，使用完0卡将怪兽送走 else b = 1;//2状态直接送走 } if (m == 0 \u0026amp;\u0026amp; mxa \u0026gt;= 2500 \u0026amp;\u0026amp; a) {//凤凰人攻击 ，并且我们有1卡 cout \u0026lt;\u0026lt; \u0026#34;haoye\\n\u0026#34;; return; } else if (m == 1 \u0026amp;\u0026amp; mxa \u0026gt; 2100 \u0026amp;\u0026amp; a) {//凤凰人防守 ，并且我们有1卡 cout \u0026lt;\u0026lt; \u0026#34;haoye\\n\u0026#34;; return; } else if (b \u0026amp;\u0026amp; n \u0026gt;=2) {//只要保证n有两张以上的卡就可以直接送走 cout \u0026lt;\u0026lt; \u0026#34;haoye\\n\u0026#34;; return; } else cout \u0026lt;\u0026lt; \u0026#34;QAQ\\n\u0026#34;; } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); LL t; //\tcin \u0026gt;\u0026gt; t; t = 1; while (t--) jiejue(); return 0; } K. 欢迎来到杭师大 直接输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll N=1e7+5; int main() { int n; cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;n;i++) { cout\u0026lt;\u0026lt;\u0026#34;Welcome to HZNU\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } L. Ayanoto 变形记 任意一个大于0的数，进行有限次的相加绝对都会加到某个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll N=1e7+5; int sovel() { int n,x; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x; if(x==0){ cout\u0026lt;\u0026lt;\u0026#34;no\u0026#34;\u0026lt;\u0026lt;endl; } else cout\u0026lt;\u0026lt;\u0026#34;yes\u0026#34;\u0026lt;\u0026lt;endl; } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--){ sovel(); } return 0; } M. P 龙学的教诲 1.每个单词每个单词的找，看标点是否在末尾\n2.按照规则输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; const LL N=2e5; LL n; string x[N]; char note; void print(int id) {//输出一整个单词 if (id != n) cout \u0026lt;\u0026lt; x[id];//不等于最后一个单词 else { int len = x[id].length(); for (int i = 0; i \u0026lt; len - 1; ++i) {//到len-2 cout \u0026lt;\u0026lt; x[id][i]; } } } LL jiejue() { //cin\u0026gt;\u0026gt;n; n=0; while (1) { cin \u0026gt;\u0026gt; x[++n]; //遇到空格看一下末尾有没有标点 int len = x[n].length(); if (x[n][len - 1] == \u0026#39;.\u0026#39;|| x[n][len - 1] == \u0026#39;!\u0026#39; or x[n][len - 1] == \u0026#39;?\u0026#39;) { note = x[n][len - 1];//标点存这 break;//找到标点直接break } } for (int i = 1; i \u0026lt;= n / 2; ++i) { print(i); //1~n/2 cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; print(n - i + 1);//n~n/2+1 if (i \u0026lt; n / 2 ||n % 2 == 1) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } if (n % 2 == 1){ //如果是奇数，偶数的最后一个数就是他 print(n / 2 + 1); } cout \u0026lt;\u0026lt; note \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin\u0026gt;\u0026gt;t;//t行若干单词 while(t--){ jiejue(); } return 0; } 补题\u0026mdash;第十三届西南民族大学程序设计竞赛(同步赛) A.《落花》\u0026amp;\u0026amp;《红衣集》 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll N=1e5+10; ll cost[N]; ll va[N]; int main() { ll n; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n-1;i++) cin\u0026gt;\u0026gt;cost[i]; for(int i=1;i\u0026lt;=n-1;i++) cin\u0026gt;\u0026gt;va[i]; ll maxco=cost[1],maxva=va[1]; for(int i=2;i\u0026lt;=n-1;i++) { if(va[i]\u0026gt;maxva){ if(va[i]\u0026gt;va[i+1]){ maxva=va[i]; maxco+=cost[i]; } else if(va[i]\u0026lt;va[i+1]){ maxva=va[i+1]; maxco+=cost[i+1]; } else{ maxva=va[i]; maxco+=min(cost[i],cost[i+1]); } } } cout\u0026lt;\u0026lt;maxco\u0026lt;\u0026lt;endl; return 0; } D.既兴风前叹，重命花下酌。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll N=1e7+5; const ll MOD=1e9+7; ll cost[N]; ll va[N]; bool f[15]; int main() { ll n; cout\u0026lt;\u0026lt;\u0026#34;FTFTTTF\u0026#34;\u0026lt;\u0026lt;endl; return 0; } E. 既兴风前叹，重命花下酌。 1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll N=1e5+10; ll cost[N]; ll va[N]; int main() { printf(\u0026#34;\\\u0026#34;xi\\\\nan\\\\min\\\\zu\\\\da\\\\xue,zhen\\\\mei!\\\u0026#34;\u0026#34;); return 0; } F.桃飘火焰焰，梨堕雪漠漠。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll N=1e7+5; const ll MOD=1e9+7; //ll time[N]; vector\u0026lt;int\u0026gt;ti; ll like[N]; bool flag[N]; int main() { int n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; for(int i=0;i\u0026lt;n;i++){ int x; cin\u0026gt;\u0026gt;x; ti.push_back(x); } for(int i=0;i\u0026lt;m;i++) cin\u0026gt;\u0026gt;like[i]; ll sum=0; for(int i=0;i\u0026lt;m;i++){ int j=like[i]-1; sum+=ti[j];//m个游戏必须玩 ti[j]=1e5; } sort(ti.begin(),ti.end()); for(int i=0;i\u0026lt;k-m;i++) { sum+=ti[i]; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } H.荷池堪作镜，盈盈可鉴心。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll N=1e7+5; const ll MOD=1e9+7; ll cost[N]; ll va[N]; ll f[N]; int main() { f[1]=1; f[2]=2; f[3]=3; for(ll i=4;i\u0026lt;=10000000;i++) f[i]=(f[i-1]%MOD+f[i-3]%MOD)%MOD; ll n; cin\u0026gt;\u0026gt;n; cout\u0026lt;\u0026lt;f[n]\u0026lt;\u0026lt;endl; return 0; } J.荷香莫深湎，终付秋风落。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll N=1e7+5; int main() { char c; bool flag; ll sum=0; while(scanf(\u0026#34;%c\u0026#34;,\u0026amp;c)!=EOF) { if(c==\u0026#39;:\u0026#39;){ flag=true; } else if(flag\u0026amp;\u0026amp;c==\u0026#39;w\u0026#39;){ flag=false; sum++; } else flag=false; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } L.相思子肯来，约在莲花岸。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll N=1e3+100; //int num[N]; //int val[N]; //int dp[N][N];//N剩余水晶数 ll xi[N],yi[N],xj[N],yj[N]; ll ki[N],kj[N]; ll juli(ll xi,ll yi,ll xj,ll yj) { return (xi-xj)*(xi-xj)+(yi-yj)*(yi-yj); } int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;xi[i]\u0026gt;\u0026gt;yi[i]\u0026gt;\u0026gt;ki[i]; } for(int i=0;i\u0026lt;m;i++){ cin\u0026gt;\u0026gt;xj[i]\u0026gt;\u0026gt;yj[i]\u0026gt;\u0026gt;kj[i]; } for(int i=0;i\u0026lt;n;i++){//我方 ll res=0,maxjuli=-1,minjuli=1e3; for(int j=0;j\u0026lt;m;j++) { if(ki[i]==1) { if(juli(xi[i],yi[i],xj[j],yj[j])\u0026gt;maxjuli) { res=j; maxjuli=juli(xi[i],yi[i],xj[j],yj[j]); } } else{ if(juli(xi[i],yi[i],xj[j],yj[j])\u0026lt;minjuli){ res=j; minjuli=juli(xi[i],yi[i],xj[j],yj[j]); } } } cout\u0026lt;\u0026lt;res+1\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;m;i++){//敌方 ll res=0,maxjuli=-1,minjuli=1e3; for(int j=0;j\u0026lt;n;j++) { if(kj[i]==1) { if(juli(xj[i],yj[i],xi[j],yi[j])\u0026gt;maxjuli) { res=j; maxjuli=juli(xj[i],yj[i],xi[j],yi[j]); } } else{ if(juli(xj[i],yj[i],xi[j],yi[j])\u0026lt;minjuli){ res=j; minjuli=juli(xj[i],yj[i],xi[j],yi[j]); } } } cout\u0026lt;\u0026lt;res+1\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 潇潇日暮时，掠水鸳鸯散。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll N=1e3+100; int num[N]; int val[N]; int dp[N][N];//N剩余水晶数 int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; //n是水晶数量 //m是手牌 for(int i=1;i\u0026lt;=m;i++) { cin\u0026gt;\u0026gt;num[i]; cin\u0026gt;\u0026gt;val[i]; } memset(dp,0,sizeof(dp)); for(int i=1;i\u0026lt;=m;i++){ for(int j=0;j\u0026lt;=n;j++){ if(num[i]\u0026gt;j){//第一个要水晶数量大 dp[i][j]=dp[i-1][j]; } else{ dp[i][j]=max(dp[i-1][j],dp[i-1][j-num[i]]+val[i]); } } } cout\u0026lt;\u0026lt;dp[m][n]\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-02-19T11:24:19+08:00","permalink":"https://IsQinna.github.io/p/2023%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83week5acm%E9%9B%86%E8%AE%AD/","title":"2023寒假训练week5（ACM集训）"},{"content":"Day1 [蓝桥杯 2021 省 B2] 特殊年份 签到题目。按照题目要求来就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=5; int main() { int ans=0; for(int j=0;j\u0026lt;5;j++) { int t; cin\u0026gt;\u0026gt;t; int a[N];\tfor(int i=1;i\u0026lt;=4;i++) { a[i]=t%10; t/=10; } if(a[2]==a[4]\u0026amp;\u0026amp;a[1]-1==a[3]) { ans++; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } [蓝桥杯 2021 省 AB2] 小平方 num要用double\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=5; typedef long long ll; int main() { ll n; cin\u0026gt;\u0026gt;n; double num; num=n; num/=2; int ans=0; for(int i=1;i\u0026lt;n;i++) { int yu; yu=i*i%n; //\tcout\u0026lt;\u0026lt;yu\u0026lt;\u0026lt;\u0026#34; \u0026#34;; if(yu\u0026lt;num) { ans++; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } [蓝桥杯 2021 省 AB2] 完全平方数 t了三个数据，得了70分 如果为偶数的话就最小质因数 如果为奇数的话就乘以一个最小的质因数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; int main() { LL n; cin \u0026gt;\u0026gt; n; LL ans = 1; for (int i=2;i*i\u0026lt;= n;i++) if(n% i==0) { int k=0; while(n%i==0) { n/=i; k++; } if(k\u0026amp;1==1) ans*= i;//盘点k是否为奇数 } if(n\u0026gt;1) ans*=n; cout \u0026lt;\u0026lt; ans\u0026lt;\u0026lt;endl; return 0; } [蓝桥杯 2021 省 AB] 砝码称重 t了五个数据，得了50分 用dfs纯纯暴力枚举所有情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 100005; int n; int a[N]; bool flag[N]; int ans; void dfs(int idx,int left,int right) { if(idx == n) { int p = abs(left - right); if(!flag[p]) ans++; flag[p] = true;//找到一个数，标记 return; } dfs(idx + 1,left,right); dfs(idx + 1,left + a[idx],right);//左边放 dfs(idx + 1,left,right + a[idx]);//右边放 } int main() { flag[0] = true;//两边不放砝码or左右两边重量相同 cin \u0026gt;\u0026gt; n; for(int i = 0 ; i \u0026lt; n ; i++) cin \u0026gt;\u0026gt; a[i]; dfs(0,0,0); cout \u0026lt;\u0026lt; ans; return 0; }#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 100005; int n; int a[N]; bool flag[N]; int ans; void dfs(int idx,int left,int right) { if(idx == n) { int p = abs(left - right); if(!flag[p]) ans++; flag[p] = true;//找到一个数，标记 return; } dfs(idx + 1,left,right); dfs(idx + 1,left + a[idx],right);//左边放 dfs(idx + 1,left,right + a[idx]);//右边放 } int main() { flag[0] = true;//两边不放砝码or左右两边重量相同 cin \u0026gt;\u0026gt; n; for(int i = 0 ; i \u0026lt; n ; i++) cin \u0026gt;\u0026gt; a[i]; dfs(0,0,0); cout \u0026lt;\u0026lt; ans; return 0; } [蓝桥杯 2021 省 B] 时间显示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int D=24; const int H=60; const int M=60; const int S=1000; typedef long long ll; int main() { ll ms; cin\u0026gt;\u0026gt;ms; //将ms化成s ll s=ms/S; s%=D*H*M;//防止过了很多天 long long int h=s/3600; //将s转化成h int m=s/H%H; s=s%H;\tif(h\u0026lt;10) cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;h; else cout\u0026lt;\u0026lt;h; cout\u0026lt;\u0026lt;\u0026#34;:\u0026#34;; if(m\u0026lt;10) cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;m; else cout\u0026lt;\u0026lt;m; cout\u0026lt;\u0026lt;\u0026#34;:\u0026#34;; if(s\u0026lt;10) cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;s; else cout\u0026lt;\u0026lt;s; } Day3 SMU Winter 2023 Round #11 (Div.2) A - BCD n可以用多少个盒子装，签到题\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main() { int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; if(n%k) cout\u0026lt;\u0026lt;n/k+1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;n/k\u0026lt;\u0026lt;endl; return 0; } B - Poku\u0026rsquo;s Vacation 分情况讨论，每级台阶比前一级严格大，所以至少公差为1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main() { int t; cin\u0026gt;\u0026gt;t; while(t--){ int n; cin\u0026gt;\u0026gt;n; if(n==1){ cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl;\tcontinue; }else{ for(int i=2;;i++){ if((i*(i+1))/2==n){//等差数列求和，算出建到第i级台阶需要多少的砖头 cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; break; } else if((i*(i+1))/2\u0026gt;n){ cout\u0026lt;\u0026lt;i-1\u0026lt;\u0026lt;endl; break; } } } } return 0; } C-Dualites in Pain - The Beginning 易知，当讲座数目最大的那门课程的讲座数目与第二大的课程讲座数目之差大于2，那么一定会在最后连续\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e3+10; typedef long long ll; int a[N]; int main() { /* int t; cin\u0026gt;\u0026gt;t; while(t--){ */ int n; cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;n;i++) { cin\u0026gt;\u0026gt;a[i]; } sort(a,a+n); if(a[n-1]-a[n-2]\u0026gt;=2){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; } else{ cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; } //\t} return 0; } D-Elder Ning 求区间的交集中有几个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; typedef long long ll; int r,l; int main() { /* int t; cin\u0026gt;\u0026gt;t; while(t--){ */ int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int lmax=0,rmin=1e5+1; for(int i=1;i\u0026lt;=m;i++) { cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; lmax=max(lmax,l);//找到最大的左区间 rmin=min(rmin,r);//找到最小的右区间 } if(lmax\u0026gt;rmin)//空集 { cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; } else{//非空，算个数 cout\u0026lt;\u0026lt;rmin-lmax+1\u0026lt;\u0026lt;endl; } //\t} return 0; } E - Hostel Cleaning 暴力t掉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e5+10; typedef long long ll; int a[N]; bool f[N]; int main() { /* int t; cin\u0026gt;\u0026gt;t; while(t--){ */ ll n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(ll i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i]; ll smin=N; for(ll i=1;i\u0026lt;=n;i++){ ll sum=a[i]; for(ll y=1;y\u0026lt;i;y++) f[y]=true;//将i前面的都标记 for(ll j=i+k;;j+=k){ if(j\u0026gt;n){ if(f[j-n]==false){//超过初始位置 smin=min(smin,sum); bool f[N];//恢复原装 break;//结束 } else\tsum+=a[j-n];//没超过初始位置，还没扫完房间。 } else\tsum+=a[j]; } } cout\u0026lt;\u0026lt;smin\u0026lt;\u0026lt;endl; //\t} return 0; } F-No Internet IPC! 剪枝+分类讨论\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e3+10; typedef long long ll; int a[N]; int main() { int t; cin\u0026gt;\u0026gt;t; while(t--){ int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; if(k==1){//当数据线只有一条时 cout\u0026lt;\u0026lt;n-1\u0026lt;\u0026lt;endl; continue; } if(n==1){//当需要更新的电脑只有一台时 cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; continue; } if(n==2){//当需要更新的电脑有两台时 cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; continue; } int now=2,ti=1; while(1){ if(now\u0026gt;=k){//已经完成更新的电脑台数大于数据线条数。k台能连接 now+=k; ti++; //时间增加一小时 }else{//否则，每台都连接数据线 now*=2; ti++; } if(now\u0026gt;=n){//所有电脑均完成更新 cout\u0026lt;\u0026lt;ti\u0026lt;\u0026lt;endl; break; } } } return 0; } Day5 A - KK 画猪 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=2e5+10; typedef long long ll; int a[N]; bool f[N]; int main() { string s; cin\u0026gt;\u0026gt;s; printf(\u0026#34; (\\\\____/)\\n\u0026#34;); printf(\u0026#34; / @__@ \\\\\\n\u0026#34;); printf(\u0026#34; ( (oo) )\\n\u0026#34;); printf(\u0026#34; `-.~~.-\u0026#39;\\n\u0026#34;); printf(\u0026#34; / \\\\\\n\u0026#34;); printf(\u0026#34; @/ \\\\_\\n\u0026#34;); printf(\u0026#34;(/ / \\\\ \\\\)\\n\u0026#34;); printf(\u0026#34; WW`----\u0026#39;WW\\n\u0026#34;); return 0; } B - KK 学几何 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; //const int N=2e5+10; const double pi=3; typedef long long ll; //int a[N]; //bool f[N]; int main() { ll n; cin\u0026gt;\u0026gt;n; double sum=0; while(n--) { int t; cin\u0026gt;\u0026gt;t; if(t==1) { double r; cin\u0026gt;\u0026gt;r; sum+=pi*r*r; } if(t==2) { double l,h; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;h; sum=sum+(l*h)/2.0; } if(t==3) { double L,W; cin\u0026gt;\u0026gt;L\u0026gt;\u0026gt;W; sum=sum+L*W; } } printf(\u0026#34;%.1lf\u0026#34;,sum); return 0; } C - KK 算日期 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; //const double pi=3; typedef long long ll; //map\u0026lt;string,int\u0026gt;bm; int a[N]; //vector\u0026lt;int\u0026gt;a; //bool f[N]; int main() { ll n; cin\u0026gt;\u0026gt;n; while(n--) { int y,year,flag,n; cin\u0026gt;\u0026gt;y\u0026gt;\u0026gt;n; //不存在，公元元年的次年是公元2年 if(y+n\u0026lt;=0) { year=abs(y+n)+1; } else{ year=y+n; } if( (year%4== 0) \u0026amp;\u0026amp; ( (year%100)!=0 ) || year%400==0 ){ //能被4整除，但不能被100整除。或者能被400整除，flag=1 flag=1; } else{ //不是闰年，flag=0 flag=0; } if(flag==1){ printf(\u0026#34;29\\n\u0026#34;); }else{ printf(\u0026#34;28\\n\u0026#34;); } } return 0; } G. KK 看跳舞 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; //const double pi=3; typedef long long ll; //map\u0026lt;string,int\u0026gt;bm; int a[N]; //bool f[N]; int main() { int _; cin\u0026gt;\u0026gt;_; while(_--) { int n; cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;n;i++) { cin\u0026gt;\u0026gt;a[i]; } if(n==1||n==2||n==3) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; } else { int f=0; for(int i=0;i\u0026lt;n;i++) { if(i==0) { if(abs(a[0]-a[1])!=1\u0026amp;\u0026amp;abs(a[0]-a[n-1])!=1) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; f=1; break; } continue; } if(i==n-1) { if(abs(a[n-1]-a[n-2])!=1\u0026amp;\u0026amp;abs(a[n-1]-a[0])!=1) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; f=1; break; } continue; } if(abs(a[i]-a[i-1]!=1\u0026amp;\u0026amp;a[i]-a[i+1])!=1) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; f=1; break; } } if(f!=1) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; } } } return 0; } H. KK 与十佳 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; //const double pi=3; typedef long long ll; //map\u0026lt;string,int\u0026gt;bm; //int a[N]; vector\u0026lt;int\u0026gt;a; //bool f[N]; int findRemoveIndex(vector\u0026lt;int\u0026gt;nums) { int negativeCount = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] \u0026lt; 0) { negativeCount++; } } int tempIndex = 0; if ((negativeCount \u0026amp; 1) == 1) { for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] \u0026lt; 0) { if (nums[tempIndex] \u0026gt;= 0 || nums[i] \u0026gt; nums[tempIndex]) { tempIndex = i; } } } return tempIndex; } else { if (nums.size() == negativeCount) { for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] \u0026lt; nums[tempIndex]) { tempIndex = i; } } return tempIndex; }; for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] \u0026gt;= 0) { if (nums[tempIndex] \u0026lt; 0 || nums[i] \u0026lt; nums[tempIndex]) { tempIndex = i; } } } return tempIndex; } } int main() { /* int _; cin\u0026gt;\u0026gt;_; while(_--) { */ int n; cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;n;i++) { int x; cin\u0026gt;\u0026gt;x; a.push_back(x); } cout\u0026lt;\u0026lt;a[findRemoveIndex(a)]\u0026lt;\u0026lt;endl; //\t} return 0; } I. KK 买股票 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; //const double pi=3; typedef long long ll; //map\u0026lt;string,int\u0026gt;bm; int arr[N]; //bool f[N]; int main() { int n; cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;n;i++) { cin\u0026gt;\u0026gt;arr[i]; } int min = arr[0]; int maxGrep = arr[1] - arr[0]; for (int i = 1; i \u0026lt; n; i++) { if( arr[i] \u0026lt; min ) min = arr[i]; if(arr[i] - min \u0026gt; maxGrep){ maxGrep = arr[i] - min; } } cout\u0026lt;\u0026lt;maxGrep\u0026lt;\u0026lt;endl; return 0; } J. KK与英语 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; //const double pi=3; typedef long long ll; //map\u0026lt;string,int\u0026gt;bm; int a[N]; //vector\u0026lt;int\u0026gt;a; //bool f[N]; int main() { string str; getline(cin,str); //\tcout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;str[0]; for (int i = 1; i \u0026lt; str.size(); i++) { if (str[i] == \u0026#39;i\u0026#39; \u0026amp;\u0026amp; str[i + 1] == \u0026#39;s\u0026#39; \u0026amp;\u0026amp; str[i - 1] == \u0026#39; \u0026#39; \u0026amp;\u0026amp; str[i + 2] == \u0026#39; \u0026#39;) { cout \u0026lt;\u0026lt; \u0026#34;was\u0026#34;; i++; continue; } cout \u0026lt;\u0026lt; str[i]; } /*\tcout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; reverse(s.begin(),s.end()); int ans=0; for(int i=0;i\u0026lt;s.size();i++) { if(s[i]!=\u0026#39;-\u0026#39;) { break; } ans++; } reverse(s.begin(),s.end()); */ return 0; } Day6 [蓝桥杯 2019 省 B] 特别数的和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool Is(int x){ int t; while(x){ t=x%10; if (t== 2||t==0||t==9||t==1) return true; else x/=10; } return false; } int main(){ int n; cin\u0026gt;\u0026gt;n; int sum=0; for(int i= 1;i\u0026lt;=n;++ i){ if(Is(i)) sum +=i; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; return 0 ; } [蓝桥杯 2019 省 AB] 完全二叉树的权值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a[100005]; int main() { int n; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i]; int maxd=0;//记最大的那层深度为maxd long long max=-100005;//记最大深度 //每层第一个数i是2的n次方 //每层最后一个数为下一层的前一个数。 int d=1; for(int i=1;i\u0026lt;=n;i*=2,d++) { long long sum=0; for(int j=i;j\u0026lt;=2*i-1\u0026amp;\u0026amp;j\u0026lt;=n;j++) { sum+=a[j]; } if(sum\u0026gt;max)\t//找到最大的那层 { max=sum; maxd=d; } } cout\u0026lt;\u0026lt;maxd\u0026lt;\u0026lt;endl; } [蓝桥杯 2021 国 ABC] 123 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll a[5]; ll Find(ll n){//二分 ll l=1,r=10000000; while(l\u0026lt;r){ ll mid=(l+r)/2;//mid代表行 //求第mid行及以前的数的个数 if((1+mid)*mid/2\u0026gt;=n) r=mid; else l=mid+1; } return r; } ll f(ll n){//第n行的和 return (1+n)*n/2; } ll Ans(ll n){//前 n 行的和 return n*(n+1)*(n+2)/6; } int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; a[1]=l-f(Find(l)-1);//前 l 行 a[2]=r-f(Find(r)-1);//前 r 行 ll ans1=Ans(Find(l)-1)+a[1]*(a[1]-1)/2;//前 l 个数的和 ll ans2=Ans(Find(r)-1)+(a[2]+1)*a[2]/2;//前 r 个数的和 cout\u0026lt;\u0026lt;ans2-ans1\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } return 0; } [蓝桥杯 2019 省 B] 等差数列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1000010; int a[N]; int main(){ int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 0; i \u0026lt; n; i ++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } sort(a, a + n); //求后面各项与第一项所有差值的最大公约数 int d = 0; for(int i = 1; i\u0026lt;n;i++) d=__gcd(d,a[i]-a[0]); if(!d) printf(\u0026#34;%d\\n\u0026#34;, n); else printf(\u0026#34;%d\\n\u0026#34;, (a[n-1]-a[0])/d+1); return 0; } [蓝桥杯 2019 省 A] 修改数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M=1e4+10; const int N=1e6+10; int fa[N]; int n,a; int Find(int x){ if(fa[x]==x) return fa[x]; return fa[x]=Find(fa[x]); } int main(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;N;++i) fa[i]=i; for(int i=1;i\u0026lt;=n;++i){ cin\u0026gt;\u0026gt;a; a=Find(a); cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34; \u0026#34;; fa[a]=a+1; } } [蓝桥杯 2019 省 A] 外卖店优先级 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+5; struct node { int ts,num; }a[N]; bool cmp(node s1,node s2) { if(s1.ts==s2.ts)return s1.num\u0026lt;s2.num; return s1.ts\u0026lt;s2.ts; } int n,m,t,ans; int last[N],sum[N];//第几号店的上一次时间，记录当前第几号店的值 bool st[N];//是否在优先缓存队列中 int main() { int tt=0;//记录上一个时间 scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;t); for(int i=1;i\u0026lt;=m;i++)scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a[i].ts,\u0026amp;a[i].num); sort(a+1,a+1+m,cmp); for(int i=1;i\u0026lt;=m;i++) { int tt,id; tt=a[i].ts;id=a[i].num; if(tt!=last[id])sum[id]-=tt-last[id]-1; if(sum[id]\u0026lt;0)sum[id]=0; if(sum[id]\u0026lt;=3)st[id]=0; sum[id]+=2; if(sum[id]\u0026gt;5)st[id]=1; last[id]=tt; } for(int i=1;i\u0026lt;=n;i++) { if(last[i]\u0026lt;t)sum[i]-=t-last[i]; if(sum[i]\u0026lt;=3)st[i]=0; } for(int i=1;i\u0026lt;=n;i++) { if(st[i])ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-02-12T11:24:19+08:00","permalink":"https://IsQinna.github.io/p/2023%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83week4acm%E9%9B%86%E8%AE%AD/","title":"2023寒假训练week4（ACM集训）"},{"content":"Day1 2023牛客寒假算法基础集训营4 A.清楚姐姐学信息论 1.看懂题目，看出规律 2.求导\n1 2 3 4 5 6 7 8 9 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { long long x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(x==3||y==3)cout\u0026lt;\u0026lt;3; // 3的时候效率最大 else cout\u0026lt;\u0026lt;min(x,y); } L.清楚姐姐的三角形I 给定三个数，两两相加已知。判断他们能否组成三角形\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; signed main() { int t; cin\u0026gt;\u0026gt;t; while(t--) { int a,b,c; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; int sum = (a+b+c)/2; int la = ((b+c) - a)/2; //a的长度 int lb = ((a+c) - b)/2; int lc = ((a+b) - c)/2; if (la \u0026lt;= 0 || lb \u0026lt;= 0 || lc \u0026lt;= 0 || ((b+c) - a) % 2!=0) {//不能是奇数，每条边不能小于0 cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; }else if(la + lb \u0026lt;= lc || la + lc \u0026lt;= lb || lb + lc \u0026lt;= la){//两边之和大于第三边 cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; }else if(abs(la - lb) \u0026gt;= lc || abs(la - lc) \u0026gt;= lb || abs(lb - lc) \u0026gt;= la){//三角形两边之差小于第三边 cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; }else{ cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;\u0026lt;\u0026lt;la\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;lb\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;lc\u0026lt;\u0026lt;endl; } } } M.清楚姐姐的三角形II 1.相邻三项一定不能组成三角形 2.只要满足两边之和等于第三边就可以 循环输出112显然不错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n,i; cin\u0026gt;\u0026gt;n; long long a[n]; a[0]=1; a[1]=1; a[2]=2; for(i=0;i\u0026lt;n;i++) { a[i]=a[i%3]; cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 每日一题【模板】并查集 完成合并和查询操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5; int n,m,z; int fa[N]; int find_(int x)//返回x的祖宗结点 { if(fa[x]!=x) fa[x]=find_(fa[x]);//如果x不等于祖宗结点 return fa[x];//让他找到x的根节点，并让x等于他的根结点 } void union_(int x,int y) { fa[find_(x)]=find_(y);//让x的祖宗结点等于y的祖宗结点 } int main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; //初始化 for(int i=0;i\u0026lt;n;i++) fa[i]=i; int x,y; for(int i=0;i\u0026lt;m;i++) { cin\u0026gt;\u0026gt;z; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(z==1){ union_(x,y); } else{ if(find_(x)==find_(y)){ cout\u0026lt;\u0026lt;\u0026#34;Y\u0026#34;\u0026lt;\u0026lt;endl; } else{ cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;\u0026lt;\u0026lt;endl; } } } return 0; } Day2 洛谷P1551 亲戚（并查集） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5; int n,m,p; int fa[N]; int find(int x)//返回x的祖宗结点 { if(fa[x]!=x) fa[x]=find(fa[x]);//如果x不等于祖宗结点 return fa[x];//让他找到x的根节点，并让x等于他的根结点 } void union_(int x,int y) { fa[find(x)]=find(y);//让x的祖宗结点等于y的祖宗结点 } int main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;p; for(int i=0;i\u0026lt;n;i++) fa[i]=i; while(m--) { int m1,m2; cin\u0026gt;\u0026gt;m1\u0026gt;\u0026gt;m2; union_(m1,m2); } while(p--) { int p1,p2; cin\u0026gt;\u0026gt;p1\u0026gt;\u0026gt;p2; if(find(p1)==find(p2)) { cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; } } return 0; } 洛谷P1196 [NOI2002] 银河英雄传说 ACwing数组元素的目标和（双指针） 找出两个升序数组，满足a[i]+b[j]=x的数对（i, j）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; const int N=1e5+100; LL a[N],b[N]; int main() { int n,m,x; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;x; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i]; for(int i=0;i\u0026lt;m;i++) cin\u0026gt;\u0026gt;b[i]; //均升序 for(int i=0,j=m-1;i\u0026lt;n;i++){ while(j\u0026gt;=0\u0026amp;\u0026amp;a[i]+b[j]\u0026gt;x) j--; if(a[i]+b[j]==x){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl; break; } } return 0; } ACwing判断子序列（双指针） 请你判断a序列是否为b序列的子序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; int a[N],b[N]; int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i]; for(int i=0;i\u0026lt;m;i++) cin\u0026gt;\u0026gt;b[i]; int i=0,j=0; while(i\u0026lt;n\u0026amp;\u0026amp;j\u0026lt;m){ if(a[i]==b[j]) i++; //匹配到一组，i++到下一个数 j++; //不管有没有匹配，j都要到下一个数 } if(i==n) cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; return 0; } ACwing最长连续不重复子序列(双指针) 一段长度为n的序列，要求找出最长的不重复子序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; int a[N]; int s[N]; int main() { int n; cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i]; int res=0; for(int i=0,j=0;i\u0026lt;n;i++) { s[a[i]]++; //当a[i]\u0026gt;1就说明a[i]不只出现1次，有重复 while(s[a[i]]\u0026gt;1) { s[a[j]]--; j++; //j从左开始，依次弹出a[j]，直到重复元素a[i]。 } res=max(res,i-j+1); } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } ACwing区间和（离散化、前缀和） 1.离散化存储每个数据 2.前缀和求区间和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 300010; //n次插入和m次查询相关数据量的上界 int n, m; int a[N];//存储坐标插入的值 int s[N];//存储数组a的前缀和 vector\u0026lt;int\u0026gt; alls; //存储（所有与插入和查询有关的）坐标 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; add, query; //存储插入和询问操作的数据 int find(int x) { //返回的是输入的坐标的离散化下标 int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return l; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { int x, c; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;c); add.push_back({x, c}); alls.push_back(x); } for (int i = 1; i \u0026lt;= m; i++) { int l , r; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); query.push_back({l, r}); alls.push_back(l); alls.push_back(r); } //排序，去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); //执行前n次插入操作 for (auto item : add) { int x = find(item.first); a[x] += item.second; } //前缀和 for (int i = 1; i \u0026lt;= alls.size(); i++) s[i] = s[i-1] + a[i]; //处理后m次询问操作 for (auto item : query) { int l = find(item.first); int r = find(item.second); printf(\u0026#34;%d\\n\u0026#34;, s[r] - s[l-1]); } return 0; } ACwing数n的二进制表示中n的第k位是几 将n右移k位（将n的第k位移到最后一位） n\u0026raquo;k ; n的最后一位是几 n \u0026amp; 1 ; 10的二进制表示 1 2 3 4 5 6 7 8 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n=10; for(int k=3;k\u0026gt;=0;k--) cout\u0026lt;\u0026lt;(n\u0026lt;\u0026lt;k)\u0026amp;1; return 0; } 二进制表示中n的第k位是几 1 2 3 4 5 6 7 8 9 10 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; int k; cin\u0026gt;\u0026gt;K; cout\u0026lt;\u0026lt;(n\u0026lt;\u0026lt;k)\u0026amp;1; } ACwing二进制中1的个数 lowbit(x)操作返回x的最后一位1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; typedef long long LL; int lowbit(int x) { return x\u0026amp;-x; } int main() { int n; cin\u0026gt;\u0026gt;n; while(n--){ int x; cin\u0026gt;\u0026gt;x; int res=0; while(x){ x-=lowbit(x); //x-x的最后一位1直到把1都减无 res++; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } ACwing区间合并 1.要求合并所有有交集的区间\n2.输出合并完成后的区间个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; typedef pair\u0026lt;int,int\u0026gt;PII; vector\u0026lt;PII\u0026gt;segs; int n; void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs){ vector\u0026lt;PII\u0026gt; res; // 左端点排序 sort(segs.begin(), segs.end()); // 左右端点初始化，-无穷 int start = -2e9, end = -2e9; for(auto seg: segs){ if(end \u0026lt; seg.first){ // 初始的[-无穷，-无穷]区间要跳过，不能装入 if(start != -2e9) res.push_back({start, end}); start = seg.first, end = seg.second; } else end = max(end, seg.second); } // 有两个作用，1.是防止n为0，把[-无穷，-无穷]压入；2.是压入最后一个（也就是当前）的区间，若n\u0026gt;=1，if可以不要 if (start != -2e9) res.push_back({start, end}); //覆盖segs segs = res; } int main() { cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;n;i++){ int l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; segs.push_back({l,r}); } merge(segs); cout\u0026lt;\u0026lt;segs.size()\u0026lt;\u0026lt;endl; return 0; } ACwing滑动窗口（单调队列） 确定滑动窗口位于每个位置时，窗口中的最大值和最小值。\n第一行输出，从左至右，每个位置滑动窗口中的最小值。\n第二行输出，从左至右，每个位置滑动窗口中的最大值。\n2.因为窗口位三个数，后面进来的数一定比前面进来的数后出。因此以最大值为例，若后一个\n入队的数比前一个入队的数大，则前面的数永远没有出头之日，要被弹出队列。 双端队列版本：\n双端队列相当于加强版vector，支持前后端弹出缺点就是比较慢\n使用它主要是因为有clear（）操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; int a[N]; int main() { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i ++ ) cin \u0026gt;\u0026gt; a[i];//读入数据 deque\u0026lt;int\u0026gt; q; for(int i = 1; i \u0026lt;= n; i++) { while(!q.empty()\u0026amp;\u0026amp; q.back() \u0026gt; a[i]) //新进入窗口的值小于队尾元素，则队尾出队列 q.pop_back(); q.push_back(a[i]);//将新进入的元素入队 if(i - k \u0026gt;= 1 \u0026amp;\u0026amp; q.front() == a[i - k])//若队头是否滑出了窗口，队头出队 q.pop_front(); if(i \u0026gt;= k)//当窗口形成，输出队头对应的值 cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt;\u0026#34; \u0026#34;; } q.clear(); cout \u0026lt;\u0026lt; endl; //最大值亦然 for(int i = 1; i \u0026lt;= n; i++) { while(!q.empty()\u0026amp;\u0026amp; q.back() \u0026lt; a[i]) q.pop_back(); q.push_back(a[i]); if(i - k \u0026gt;= 1 \u0026amp;\u0026amp; a[i - k] == q.front()) q.pop_front(); if(i \u0026gt;= k) cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } Day3 SMU Winter 2023 Round #9 (Div.2) A. Who is The 19th ZUCCPC Champion 随便输出一个字符串就行。\n1 2 3 4 5 6 7 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ cout\u0026lt;\u0026lt;\u0026#34;Ranni the Witch\\n\u0026#34;; return 0; } B. Jiubei and Overwatch t\u0026lt;=k,damage=tx; t\u0026gt;k,damage=kx+(t-k)y; 当时间小于k的时候，就是t倍的x。超过k的话，超过多少就加多少倍的y。 排序找出最大的防御力的怪物，因为同时攻击，最大的灭了，其他小的自然就灭了。 分成两部分求解： 没超过k 超过k 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=101; int n,k,x,y; int a[N]; void sovle() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i]; sort(a,a+n,greater\u0026lt;int\u0026gt;()); //\tcout\u0026lt;\u0026lt;a[0]\u0026lt;\u0026lt;endl; for(int t=1;;t++){ if(t\u0026lt;=k) { int dam=t*x; if(a[0]\u0026lt;=dam) { cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;endl; break; } } else{ int dam=k*x+(t-k)*y; if(a[0]\u0026lt;=dam) { cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;endl; break; } } } } int main() { int _; cin\u0026gt;\u0026gt;_; while(_--){ sovle(); } } C. Ah, It\u0026rsquo;s Yesterday Once More 交换排序：\n1 2 3 for(i-\u0026gt;n) for(j-\u0026gt;n) if(ai\u0026lt;aj) swap(ai,aj); 冒泡排序：\n1 2 3 for(i-\u0026gt;n) for(j-\u0026gt;n-1) if(aj\u0026gt;a（j+1）) swap(ai,a(j+1)); 题目要求找出全排列数组a，使得冒泡排序和交换排序的交换次数相同。 显然倒序输出的时候相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+100; void sovle() { int n; cin\u0026gt;\u0026gt;n; for(int i=n;i\u0026gt;0;i--) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } int main() { int _; cin\u0026gt;\u0026gt;_; while(_--){ sovle(); } } F. Sum of Numerators 将分数化简到最小的分子相加。 1.奇数时：分子直接相加 2.偶数时：分子不断除2 3.找规律\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long int ll; ll t; ll n,k; int main(){ scanf(\u0026#34;%lld\u0026#34;,\u0026amp;t); while(t--){ scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;k); ll sum=n*(n+1)/2; //等差数列前n项和，未经处理的分子的和。 while(n\u0026amp;\u0026amp;k){ n/=2; //会被约分的数字个数每次都是总长的一半 k--; //每次被约分，2的次数减一 sum-=n*(n+1)/2; //每次被约分掉的总和是等差数列求1到被约分掉的数字个数之和。 } printf(\u0026#34;%lld\\n\u0026#34;,sum); } return 0; } L. Monster Tower 塔高为n，每层都有一个怪物，怪物能量为ai，找出初始的攻击力x最小可以为多少。 1.每次只能在1~k层攻击怪物，每次消灭掉怪物i之后，自身的攻击力将会提升ai 2.消灭掉这一层怪物后，这一层会消失，这层往上的层数会逐层-1 思路： 打怪的顺序是唯一的，所以维护一个有 k 个元素的小根堆，每次处理最小的元素，如果现有能力值大于怪的能力值，加上怪的能力值，否则更新初始值；\n每遇到一个打不过的怪，最小可能初始值 = 怪的能力值-前面获得的能力值总和，用这个值去更新之前的 初始值，取其中大的；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1e6+100; ll t,n,k; ll a[N]; priority_queue\u0026lt;ll,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt; \u0026gt;pmin; ll sta,now; int main() { cin\u0026gt;\u0026gt;t; while(t--) { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; sta=0;now=0; for(int i=1;i\u0026lt;=n;i++) { scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); } for(int i=1;i\u0026lt;=n;i++)//每个堆里只有k个元素 { if(pmin.empty()||pmin.size()\u0026lt;k) pmin.push(a[i]);//注意判空 else { ll s=pmin.top(); pmin.pop(); if(now\u0026gt;=s) { now+=s; }//总能力值大于怪的能力值 else { sta=max(sta,s-now); now+=s; }//更新初始值，注意更新方式 pmin.push(a[i]); } } while(!pmin.empty())//清空堆 { ll s=pmin.top(); pmin.pop(); if(now\u0026gt;=s) { now+=s; } else { sta=max(sta,s-now); now+=s; } } cout\u0026lt;\u0026lt;sta\u0026lt;\u0026lt;endl;\t} return 0; } Day4 洛谷P1111 修复公路（并查集） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e6; int fa[N],num,ans; struct node{ int x,y,t;\t}e[N]; bool operator\u0026lt;(node a,node b){//重载小于运算符 return a.t\u0026lt;b.t; } int find(int x) { if(fa[x]!=x) { fa[x]=find(fa[x]); } return fa[x]; } void union_(int x,int y,int t) { if(find(x)==find(y)); else{ fa[find(x)]=find(y); num++; ans=max(ans,t); } } int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++) fa[i]=i; for(int i=1;i\u0026lt;=m;i++) { cin\u0026gt;\u0026gt;e[i].x\u0026gt;\u0026gt;e[i].y\u0026gt;\u0026gt;e[i].t; } sort(e+1,e+m+1);//按照时间排序 for(int i=1;i\u0026lt;=m;i++) union_(e[i].x,e[i].y,e[i].t);//按时间大小合并 if(num!=n-1) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } leetcode242.有效字母异位词（数组哈希） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: bool isAnagram(string s, string t) { if(s.size()!=t.size())return 0; int res[26]; for(int i=0;i\u0026lt;26;i++) res[i]=0; for(int i=0;i\u0026lt;s.size();i++){ res[s[i]-\u0026#39;a\u0026#39;]++; } for(int i=0;i\u0026lt;t.size();i++){ res[t[i]-\u0026#39;a\u0026#39;]--; } for(int i=0;i\u0026lt;26;i++){ if(res[i]){ return 0; } } return 1; } }; leetcode349.两数组的交集(set哈希) 1.用unodered_set模拟hash处理\n2.用数组模拟hash处理\n法1： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { unordered_set\u0026lt;int\u0026gt;result;//存放交集 unordered_set\u0026lt;int\u0026gt; num_set(nums1.begin(),nums1.end());//直接将num1转化为unoderde_set类型 for(int num : nums2)//看num2里的元素是否在num1中出现 { if(num_set.find(num)!=num_set.end())//如果找不到对应元素，返回的是末尾的迭代器。 { result.insert(num); } } return vector\u0026lt;int\u0026gt;(result.begin(),result.end()); } }; 法2： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { unordered_set\u0026lt;int\u0026gt;result;//存放交集 int hash[1005]={0};//hash数组，初始化为0 for(int num : nums1) { hash[num]=1; } for(int num : nums2) { if(hash[num]){ result.insert(num);//nums2的元素出现过,直接插入result中 } } return vector\u0026lt;int\u0026gt;(result.begin(),result.end()); } }; leetcode1.两数之和（map哈希） 找出和为目标值target的那两个整数,并返回它们的数组下标。 num1+num2=target 1.key值存放num2，value存放下标。\n2.遍历num1，看看map中是否存储了num2，防止重复计算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map \u0026lt;int,int\u0026gt; map;//无序，first存储数值，second存储下标 for(int i=0;i\u0026lt;nums.size();i++){//查询map中是否有相加等于target的元素 auto it=map.find(target-nums[i]); if(it!=map.end())//map中，找得到和为target的另一个数的下标 return {it-\u0026gt;second,i}; // 如果没找到匹配对，就把访问过的元素和下标加入到map中 map.insert(pair\u0026lt;int,int\u0026gt;{nums[i],i}); } return {}; } }; leetcode454.四数相加（II）（map哈希） 给定四个数组，求num1[i]+num2[j]+num3[k]+num4[l]=target,一共有几种方法\n1.朴素写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int fourSumCount(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, vector\u0026lt;int\u0026gt;\u0026amp; nums3, vector\u0026lt;int\u0026gt;\u0026amp; nums4) { unordered_map\u0026lt;int,int\u0026gt;map; for(int i=0;i\u0026lt;nums1.size();i++){//将nums1+nums2的值存在map中 for(int j=0;j\u0026lt;nums2.size();j++){ map[nums1[i]+nums2[j]]++; } } int conut=0; for(int i=0;i\u0026lt;nums3.size();i++){ for(int j=0;j\u0026lt;nums4.size();j++){ auto it=-(nums3[i]+nums4[j]); if(map.find(it)!=map.end()){//找到了 conut+=map[it]; } } } return conut; } }; 2.优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int fourSumCount(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, vector\u0026lt;int\u0026gt;\u0026amp; nums3, vector\u0026lt;int\u0026gt;\u0026amp; nums4) { unordered_map\u0026lt;int,int\u0026gt;map; for(int i : nums1){//将nums1+nums2的值存在map中 for(int j : nums2){ map[i+j]++; } } int conut=0; for(int i : nums3){ for(int j : nums4){ auto it=-(i+j); if(map.find(it)!=map.end()){//找到了 conut+=map[it]; } } } return conut; } }; leetcode15.三数之和（双指针） 1.给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c 。使得 a\n+b+c=0请你找出所有满足条件且不重复的三元组。\n2.答案中不可以包含重复的三元组。\n详细介绍： 例如答案为： nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 这题的麻烦主要时去重\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(),nums.end());//排序 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; for(int i=0;i\u0026lt;nums.size();i++){ if(nums[i]\u0026gt;0) return result;//最小的数大于0，说明不管怎相加都不会等于0 if(i\u0026gt;0\u0026amp;\u0026amp;nums[i]==nums[i-1])//去重复 continue; int l=i+1; int r=nums.size()-1; while(l\u0026lt;r){ if(nums[i]+nums[l]+nums[r]\u0026gt;0){ r--; } else if(nums[i]+nums[l]+nums[r]\u0026lt;0){ l++; } else{ result.push_back(vector\u0026lt;int\u0026gt;{nums[i] ,nums[l] ,nums[r]}); //接下来要对l和r去重 while(l\u0026lt;r\u0026amp;\u0026amp;nums[l]==nums[l+1]) l++; while(l\u0026lt;r\u0026amp;\u0026amp;nums[r]==nums[r-1]) r--; //找到result后，将l和r收缩 l++; r--; } } } return result; } }; leetcode18.四数之和（双指针） 1.剪枝 2.去重 3.三数之和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(),nums.end()); for(int a=0;a\u0026lt;nums.size();a++){ if(nums[a]\u0026gt;0\u0026amp;\u0026amp;target\u0026gt;0\u0026amp;\u0026amp;nums[a]\u0026gt;target){//剪枝 break; } if(a\u0026gt;0\u0026amp;\u0026amp;nums[a]==nums[a-1]){//对a去重 continue; } for(int b=a+1;b\u0026lt;nums.size();b++){//剪枝 if(nums[b]+nums[a]\u0026gt;0\u0026amp;\u0026amp;target\u0026gt;0\u0026amp;\u0026amp;nums[a]+nums[b]\u0026gt;target){ break; } if(b\u0026gt;a+1\u0026amp;\u0026amp;nums[b]==nums[b-1]){//对b去重 continue; } int c=b+1,d=nums.size()-1; while(c\u0026lt;d){ // nums[a] + nums[b] + nums[c] + nums[d] \u0026gt; target 会溢出 if((long)nums[a]+nums[b]+nums[c]+nums[d]\u0026gt;target) d--; else if((long)nums[a]+nums[b]+nums[c]+nums[d]\u0026lt;target) c++; else{ result.push_back(vector\u0026lt;int\u0026gt;({nums[a],nums[b],nums[c],nums[d]})); //获得答案之后对c和d进行去重 while(c\u0026lt;d\u0026amp;\u0026amp;nums[c]==nums[c+1]) c++; while(c\u0026lt;d\u0026amp;\u0026amp;nums[d]==nums[d-1]) d--; //获得答案后将范围收缩 c++; d--; } } } } return result; } }; leetcode344.反转字符串（I）（双指针） 要求空间复杂度o(1)即不能另外开一个字符串，而改变s字符串的值\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { char t; for(int i=0,j=s.size()-1;i\u0026lt;j;i++,j--){ t=s[j]; s[j]=s[i]; s[i]=t; } } }; leetcode541.反转字符串（II）（双指针） 给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。\n如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n示例:\n输入: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 输出: \u0026ldquo;bacdfeg\u0026rdquo;\n1.可以自己写一个反转函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: string reverseStr(string s, int k) { for(int i=0;i\u0026lt;s.size();i+=(2*k)){ // 以2k间距来操作 if(i+k\u0026lt;=s.size()){ //i后面字符大于k个，反转k个字符 for(int j=i,l=i+k-1;j\u0026lt;l;j++,l--){//注意在[i,i+k)区间内反转 char t=s[j]; s[j]=s[l]; s[l]=t; } continue; } else{ //到最后，i后面的字符小于k个 for(int j=i,l=s.size()-1;j\u0026lt;l;j++,l--){ char t=s[j]; s[j]=s[l]; s[l]=t; } } } return s; } }; 2.可以用stl函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: string reverseStr(string s, int k) { for(int i=0;i\u0026lt;s.size();i+=(2*k)){ // 以2k间距来操作 if(i+k\u0026lt;=s.size()){ //i后面字符大于k个，反转k个字符 reverse(s.begin() + i, s.begin() + i + k ); continue; } else{ //到最后，i后面的字符小于k个 reverse(s.begin() + i, s.end()); } } return s; } }; Day6 洛谷P1536 村村通（并查集） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5; int n,m; int fa[N]; int find(int x)//返回x的祖宗结点 { if(fa[x]!=x) fa[x]=find(fa[x]);//如果x不等于祖宗结点 return fa[x];//让他找到x的根节点，并让x等于他的根结点 } void union_(int x,int y) { fa[find(x)]=find(y);//让x的祖宗结点等于y的祖宗结点 } int main() { while(1) { cin\u0026gt;\u0026gt;n; if(n==0) return 0; cin\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++) fa[i]=i;//城镇 while(m--) { int m1,m2; cin\u0026gt;\u0026gt;m1\u0026gt;\u0026gt;m2;//由这条道路相连的城镇编号 union_(m1,m2); } int ans=0; for(int i=1;i\u0026lt;=n;i++) { if(find(i)==i) { ans++; } } cout\u0026lt;\u0026lt;ans-1\u0026lt;\u0026lt;endl; } return 0; } leetcode27. 移除元素（双指针） 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int slow=0; for(int fast=0;fast\u0026lt;nums.size();fast++){ if(nums[fast]!=val){ //快指针的值不等于val时将元素的值赋给nums[slow] nums[slow]=nums[fast]; slow++; //慢指针移动 } } return slow; } }; leetcode151. 反转字符串中的单词（双指针） 给定一个字符串，逐个翻转字符串中的每个单词。\n示例 1： 输入: \u0026ldquo;the sky is blue\u0026rdquo; 输出: \u0026ldquo;blue is sky the\u0026rdquo;\n示例 2： 输入: \u0026quot; hello world! \u0026quot; 输出: \u0026ldquo;world! hello\u0026rdquo; 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n示例 3： 输入: \u0026ldquo;a good example\u0026rdquo; 输出: \u0026ldquo;example good a\u0026rdquo; 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 一定要记得resize操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public: string reverseWords(string s) { //空格移除操作 int slow=0;//慢指针 for(int fast=0;fast\u0026lt;s.size();fast++){//快指针 if(s[fast]!=\u0026#39; \u0026#39;)//如果fast指向的元素不为空格 { if(slow!=0)//如果slow指向的元素不为首元 { s[slow]=\u0026#39; \u0026#39;;//就在单词前加空格 slow++; } while(fast\u0026lt;s.size()\u0026amp;\u0026amp;s[fast]!=\u0026#39; \u0026#39;)//当在数组内，且不等于空格时 { s[slow]=s[fast];//覆盖 slow++; fast++; } } } s.resize(slow); //slow的大小即为去除多余空格后的大小。 //反转操作，先反转整个句子，再逐个反转单词 for(int i=0,j=s.size()-1;i\u0026lt;j;i++,j--) { char t=s[i]; s[i]=s[j]; s[j]=t; } int st=0;//起始的单词字母在0处 for(int i=0;i\u0026lt;=s.size();i++){ if(s[i]==\u0026#39; \u0026#39;||i==s.size()){ //到达单词结尾 for(int l=st,r=i-1;l\u0026lt;r;l++,r--){ char t=s[l]; s[l]=s[r]; s[r]=t; } st=i+1; //新单词的起始位置 } } return s; } }; ","date":"2023-02-05T11:24:19+08:00","permalink":"https://IsQinna.github.io/p/2023%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83week3acm%E9%9B%86%E8%AE%AD/","title":"2023寒假训练week3（ACM集训）"},{"content":"Day1 SMU Winter 2023 Round #5 (Div.2) A. Lucky? 1.字符转数字 2.相加并比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s; int a[10]; int main() {\tint t; cin\u0026gt;\u0026gt;t; int sum1,sum2; while(t--){ cin\u0026gt;\u0026gt;s; sum1=0,sum2=0; for(int i=0;i\u0026lt;6;i++){ a[i]=s[i]-\u0026#39;0\u0026#39;; } for(int i=0;i\u0026lt;3;i++){ sum1+=a[i]; } for(int i=3;i\u0026lt;6;i++){ sum2+=a[i]; } if(sum1==sum2){ printf(\u0026#34;YES\\n\u0026#34;); } else{ printf(\u0026#34;NO\\n\u0026#34;); } } return 0; } B.Equal Candies 1.找最小值 2.每个分别相减求和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(void) { int n; cin \u0026gt;\u0026gt; n; int m; int a[1005]; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; m; int minv = 1e8;//赋一个极大值 int sum = 0; for (int j = 0; j \u0026lt; m; j++) { cin \u0026gt;\u0026gt; a[j]; minv = min(minv, a[j]);//找最哪个盒子里糖果最少 } for (int j = 0; j \u0026lt; m; j++) { sum += a[j] - minv;//每一个盒子里的糖果减最少的就是要吃的 } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } } C.Most Similar Words 1.找最相似的数的意思是找相减的数最小的 2.直接挨个相减\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t, n, m, i, j, x; int min, sum; char C[51][9]; cin\u0026gt;\u0026gt;t; while (t--) {//t组case cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; min = 300; for (i = 0; i\u0026lt;n; i++) scanf(\u0026#34;%s\u0026#34;, C[i]);//要比较的字符串，n个串串 for (i = 0; i\u0026lt;n; i++) //每个字符串都互相比较一下 { for (j = i + 1; j\u0026lt;n; j++) { sum = 0; for (x = 0; x\u0026lt;m; x++)//每个字符串的每个字母互相比较 { if (C[i][x]\u0026gt;C[j][x]) { sum = sum + (C[i][x] - C[j][x]); } else { sum = sum + (C[j][x] - C[i][x]); } } if (sum\u0026lt;min) //找最小的 { min = sum; } } } printf(\u0026#34;%d\\n\u0026#34;, min);//输出最小的 } return 0; } D.X-Sum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 210; typedef long long LL; int w[N][N]; int T,n,m; LL get(int x,int y)//x的攻击范围相加 { int res=w[x][y]; for(int i=1;i\u0026lt;=200;i++) { if(x-i\u0026gt;=1\u0026amp;\u0026amp;y-i\u0026gt;=1) res+=w[x-i][y-i];//左上角“\\” if(x+i\u0026lt;=n\u0026amp;\u0026amp;y+i\u0026lt;=m) res+=w[x+i][y+i];//右上角“/” if(x+i\u0026lt;=n\u0026amp;\u0026amp;y-i\u0026gt;=1) res+=w[x+i][y-i];//左下角“/” if(x-i\u0026gt;=1\u0026amp;\u0026amp;y+i\u0026lt;=m) res+=w[x-i][y+i];//右下角“\\” } return res; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while(T--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=m;j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i][j]);//存图 } LL res=0; for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=m;j++) { res=max(res,get(i,j));//棋盘上每个点都遍历一遍，找x的攻击范围最大的 } printf(\u0026#34;%lld\\n\u0026#34;,res); } return 0; } E.Eating Queries 1.对于每次询问，回答最少要吃多少糖果\u0026gt;=询问的数目 2.如果全加起来都不大于cout\u0026laquo;-1 思路：排序，一种糖果只能吃一次，因此依次遍历直到所有糖果都没有\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int T;cin\u0026gt;\u0026gt;T; while(T--) { int n,q;cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; vector\u0026lt;int\u0026gt; a(n); for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;a[i]; sort(a.begin(),a.end(),greater\u0026lt;int\u0026gt;());//从大到小排序 for(int i=1;i\u0026lt;n;i++) a[i]+=a[i-1];//前缀和，吃i种糖果的糖分，我们约定a[0]=0； for(int i=0;i\u0026lt;q;i++) { int x; cin\u0026gt;\u0026gt;x; if(x\u0026gt;a[n-1])//x大于所有糖果加起来 cout\u0026lt;\u0026lt;\u0026#34;-1\u0026#34;\u0026lt;\u0026lt;endl; else { int pos=lower_bound(a.begin(),a.end(),x)-a.begin();//找到大于等于pos的最小下标 cout\u0026lt;\u0026lt;pos+1\u0026lt;\u0026lt;endl;//从0开始记得+1 } } } return 0; } F. Longest Strike 1.给定一个数组，要求找到连续的区间[l,r]使得区间长度最大\n2.区间内的数满足\u0026gt;=k\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 3 * 1e5 + 100; int T; int n, m; int a[N], s[N], num[N]; bool cmp(long long aa, long long b) { return aa \u0026gt; b; } int main() { cin \u0026gt;\u0026gt; T; while (T--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } sort(a + 1, a + 1 + n); int idx = 0; for (int i = 1; i \u0026lt;= n; i++) { int j = i; while (a[j] == a[j + 1] \u0026amp;\u0026amp; (j + 1 \u0026lt;= n))j++; s[++idx] = j - i + 1; num[idx] = a[i]; i = j; } int l = -1, r = -1, len = -1; for (int i = 1; i \u0026lt;= idx; i++) { int j = i; while ((j + 1 \u0026lt;= idx) \u0026amp;\u0026amp; s[j] \u0026gt;= m \u0026amp;\u0026amp; s[j + 1] \u0026gt;= m \u0026amp;\u0026amp; (num[j + 1] == num[j] + 1))j++; if ((l == -1 || num[j] - num[i] \u0026gt; len) \u0026amp;\u0026amp; s[j] \u0026gt;= m) { l = i, r = j; len = num[j] - num[i]; } i = j; } if (l != -1) { printf(\u0026#34;%d %d\\n\u0026#34;, num[l], num[r]); // cout \u0026lt;\u0026lt; num[l] \u0026lt;\u0026lt; num[r] \u0026lt;\u0026lt; endl; } else printf(\u0026#34;-1\\n\u0026#34;); } return 0; } G.White-Black Balanced Subtrees 1.储存树的模板\n2.遍历树每个结点的模板\n3.dfs遍历所有结点的模板\n4.用结构体或者pair来存储两种颜色和有多少棵子树两种颜色相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include\u0026lt;bits/stdc++.h\u0026gt; //树的遍历 using namespace std; const int N = 2 * 1e4 + 100; int T; int n, m; int e[N], ne[N], h[N], idx; string s; int res = 0; typedef pair\u0026lt;pair\u0026lt;int, int\u0026gt;, int\u0026gt; pii; void add(int a, int b) // 添加一条边a-\u0026gt;b { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } pii dfs(int x) { int W = 0, B = 0; W += s[x - 1] == \u0026#39;W\u0026#39; ? 1 : 0;//判断这个结点是什么颜色，对应颜色个数加1 B += s[x - 1] == \u0026#39;B\u0026#39; ? 1 : 0; for (int i = h[x]; i != -1; i = ne[i]){//遍历每个父子节点的每个结点 int j = e[i]; pii P = dfs(j);//求每一个父节点下的子节点的颜色 W += P.first.first;//相加可得父节点的颜色 B += P.first.second; } if (W == B \u0026amp;\u0026amp; W != 0) { res++; //cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;; } pii p = {{W, B}, res};//用pii类型存储 return p; } int main() { cin \u0026gt;\u0026gt; T; while (T--) { res = 0; idx = 0; memset(h, -1, sizeof h); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n);//有n个结点 for (int i=2;i\u0026lt;=n;i++) {//求的就是不包含根节点的子树 int x; scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); add(x, i); } cin \u0026gt;\u0026gt; s;//每个结点的颜色 dfs(1);//从根节点遍历 printf(\u0026#34;%d\\n\u0026#34;, res); } return 0; } Day2 闲来无事 ACwing-第k个数(快速选择法排序) 1.快速选择法排序 2.找到第k个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; int a[N]; int n,k; int q_sort(int l,int r,int k){ if(l==r) return a[l];//只有一个数 int x=a[l],i=l-1,j=r+1; while(i\u0026lt;j) { while(a[++i]\u0026lt;x);//\u0026lt;a[l]放在左边 while(a[--j]\u0026gt;x);//\u0026gt;a[l]放在右边 if(i\u0026lt;j) swap(a[i],a[j]);//不符合就交换位置 } int sl= j-l+1;//\u0026lt;a[l]的个数 if(k\u0026lt;=sl) return q_sort(l,j,k);//k在左边,包括j return q_sort(j+1,r,k-sl);//k在右边,不包括k } int main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for(int i=0;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;a[i]; } cout\u0026lt;\u0026lt;q_sort(0,n-1,k)\u0026lt;\u0026lt;endl;//0排到n-1 } ACwing-逆序对的数量(归并法排序) 1.用归并分别求左,右,中间的逆序对 2.其实都是mid-i+1一直递归求出来的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e6; int n; long long a[N]; long long tmp[N];//中间数组 long long meger_sort(int l,int r){ if(l\u0026gt;=r) return 0; int mid=l+r\u0026gt;\u0026gt;1; //求逆序对 long long res=meger_sort(l,mid)+meger_sort(mid+1,r); //归并 int k=0,i=l,j=mid+1; //tmp从0开始 while(i\u0026lt;=mid\u0026amp;\u0026amp;j\u0026lt;=r)//任意一边没有到头 { if(a[i]\u0026lt;=a[j])//如果右边的大于左边，先将左边放入tmp { tmp[k++]=a[i++]; } else { tmp[k++]=a[j++]; res+=mid-i+1;//如果左边的大于右边,逆序了,记录一下 //注意,是以mid为边界,不要干涉到mid+1这边,因为这边也继续递归算出 } } //有一边先结束，扫尾 while(i\u0026lt;=mid) tmp[k++]=a[i++]; while(j\u0026lt;=r) tmp[k++]=a[j++]; //物归原主，将tmp的值复制到从l开始的数组中 for(int i=l,j=0;i\u0026lt;=r;i++,j++){ a[i]=tmp[j]; } return res; } int main() { cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;a[i]; } cout\u0026lt;\u0026lt;meger_sort(0,n-1)\u0026lt;\u0026lt;endl;//n个数,求到逆序对的个数，并排好序输出 return 0; } ACwing-三次方根(浮点数二分) 1.用double 2.浮点数二分不需要考虑边界\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; double binary(double n) { double l=-10000,r=10000; while(r-l\u0026gt;1e-8){ double mid=(l+r)/2; if(mid*mid*mid\u0026gt;=n) r=mid; else l=mid; } return l; } int main() { double n; scanf(\u0026#34;%lf\u0026#34;,\u0026amp;n); printf(\u0026#34;%lf\u0026#34;,binary(n)); return 0; } ACwing-前缀和(一维) 1.从1开始 2.默认0位置为0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const long long N=100005; long long a[N]; long long s[N]; long long m,n; int main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(long long i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); for(long long i=1;i\u0026lt;=n;i++) s[i]=s[i-1]+a[i]; while(m--){ long long l,r; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;l,\u0026amp;r); printf(\u0026#34;%lld\\n\u0026#34;,s[r]-s[l-1]); } return 0;\t} ACwing-子矩阵(二维前缀和) 1.二维数组不能开太大 2.记二维前缀和模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e3+10; int a[N][N]; int s[N][N]; int n,m,q; int main() { scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;q); for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=m;j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i][j]); //初始化前缀和数组 for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];//这条求s[i][j] } } //q次询问 while(q--){ int x1,y1,x2,y2; scanf(\u0026#34;%d%d%d%d\u0026#34;,\u0026amp;x1,\u0026amp;y1,\u0026amp;x2,\u0026amp;y2); printf(\u0026#34;%d\\n\u0026#34;,s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]);//这条求某个小方形面积 } return 0; } 2023寒假牛客算法基础集训营-A World Final? World Cup! (I) 1.给出10次点球的结果 2.有奇数，偶数区分A和B的结果 3.如果A和B比赛进行到某个阶段，后面A全胜（或者后面B全胜）A都无法超过B（B都无法超过A），说明判断出来了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while(t--) { string s; cin\u0026gt;\u0026gt;s; bool f=false; int a1=0,b1=0; int res=0; for(int i=0;i\u0026lt;10;i++){//从0开始奇数表示B，偶数表示A if(i%2==0){ if(s[i]==\u0026#39;1\u0026#39;){ a1++; } } else{ if(s[i]==\u0026#39;1\u0026#39;){ b1++; } } res++;//记录这是第几场比赛 if(b1\u0026gt;a1+(10-i-1)/2||a1\u0026gt;b1+(10-i)/2){//奇数偶数不一样 f=true; break; } } if(f){ cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } else{ cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; } } return 0; } ACwing-差分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5+10; int b[N];//差分数组 int a[N];//操作数组 int insert(int l,int r,int c){ b[l]+=c; b[r+1]-=c; } int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; insert(i,i,a[i]);//初始时，ab数组为0，a要插入值 } //询问 while(m--) { int l,r,c; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;c; insert(l,r,c); } for(int i=1;i\u0026lt;=n;i++){ a[i]=a[i-1]+b[i];//差分数组b的前缀和等于a } for(int i=1;i\u0026lt;=n;i++){ cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } ACwing-差分矩阵（二维差分） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e3+100; int b[N][N];//差分数组 int a[N][N];//操作数组 void insert(int x1,int y1,int x2,int y2,int c){ b[x1][y1]+=c; b[x2+1][y1]-=c; b[x1][y2+1]-=c; b[x2+1][y2+1]+=c; } int main() { int n,m,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;q; for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ cin\u0026gt;\u0026gt;a[i][j]; insert(i,j,i,j,a[i][j]); } } //询问 while(q--) { int x1,y1,x2,y2,c; cin\u0026gt;\u0026gt;x1\u0026gt;\u0026gt;y1\u0026gt;\u0026gt;x2\u0026gt;\u0026gt;y2\u0026gt;\u0026gt;c; insert(x1,y1,x2,y2,c); } for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+b[i][j]; } } for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ cout\u0026lt;\u0026lt;a[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } return 0; } Day 3 2023牛客寒假算法基础集训营2 A. Tokitsukaze and a+b=n (easy) 1.给定两个区间，分别在这连个区间内找a,b\n2.求a+b=n的种类数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N=1e5+10; int main() { int t; cin\u0026gt;\u0026gt;t; ll n; cin\u0026gt;\u0026gt;n; while(t--) { ll res=0; ll l1,r1,l2,r2; cin\u0026gt;\u0026gt;l1\u0026gt;\u0026gt;r1\u0026gt;\u0026gt;l2\u0026gt;\u0026gt;r2; for(int i=l1;i\u0026lt;=r1;i++){ if(n-i\u0026gt;=l2\u0026amp;\u0026amp;n-i\u0026lt;=r2){ res++; } } } return 0; } B.Tokitsukaze and a+b=n (medium) 1.这题o(n)也不行，直接tle 2.数学规律，因为两个区间都是公差为1的等差数列 3.他们之间都是找到一个数可以a+b=n，之后就全部对应相加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int t,n,l1,l2,r1,r2; int main() { cin\u0026gt;\u0026gt;t; while(t--) { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;l1\u0026gt;\u0026gt;r1\u0026gt;\u0026gt;l2\u0026gt;\u0026gt;r2; if(l1+l2\u0026gt;n||r1+r2\u0026lt;n){ cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; continue; } cout\u0026lt;\u0026lt;max(0,min(n-l1,r2)-max(n-r1,l2)+1)\u0026lt;\u0026lt;endl; } } C.Tokitsukaze and a+b=n (hard) 1,本题不再是两个区间，而是m个区间中任选两个\n2.本题要求输出%998244353的结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 4e5+10; const int mod = 998244353; #define int long long int n,m; int a[N]; signed main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int ans =0; for(int i=1;i\u0026lt;=m;i++)//m次循环找到每次方法 { int l,r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; a[l]+=1; a[r+1]-=1; ans= (ans-max(min(n-l,r)-n+min(n-l,r)+1, (int)0))%mod; } for(int i=1;i\u0026lt;=2e5+10;i++) a[i] = (a[i-1]+a[i])%mod; for(int i=0;i\u0026lt;=n;i++) ans=(ans+a[i]*a[n-i]%mod)%mod; cout\u0026lt;\u0026lt;ans; } D.Tokitsukaze and Energy Tree 1.n个结点的能量数，根节点为1\n2.n个能量球，能量树的每个节点都恰好有一个能量球\n3.放置能量球在某结点之后，能获得以这个结点为根节点的子树的所有能量、\n4.输出最多能获得多少总能量\n思路：\n1.树要从下往上遍历\n2.每个结点被加次数等于深度\n3.树形dfs 我还不熟练\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; int n,v[200010],x,h[200010];//v存储能量球的能量，h来记录每个结点的深度 LL ans;//用来记录最大总能量 vector\u0026lt;int\u0026gt;g[200010]; void dfs(int x,int d) { h[x] = d; for (int i = 0;i \u0026lt; g[x].size();i++) { dfs(g[x][i],d+1); //若没找到父亲节点就是0，但h从1开始 } } int main() { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); //n个能量球 for (int i = 2;i \u0026lt;= n;i++) //i的父亲节点x,并顺便把每个结点命名为1~n { scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); g[x].push_back(i); } for (int i = 1;i \u0026lt;= n;i++) //能量球的能量 { scanf(\u0026#34;%d\u0026#34;,\u0026amp;v[i]); } dfs(1,1); sort(v+1,v+1+n,greater\u0026lt;int\u0026gt;()); //能量升序 sort(h+1,h+1+n,greater\u0026lt;int\u0026gt;()); //根结点升序 LL ans = 0; for (int i = 1;i \u0026lt;= n;i++) { ans += 1ll*h[i]*v[i]; //遍历每个结点 } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } E.Tokitsukaze and Function 1.均值不等式 2.二分，寻找sqrt(n)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;bits/stdc++.h\u0026gt; #define PII pair\u0026lt;int, int\u0026gt; #define pll pair\u0026lt;long, long\u0026gt; #define int long long using namespace std; const int maxn = 5e5 + 10; // 记得看数组范围是否开够 const int inf = 0x3f3f3f3f; int n; int f(int x) { return n / x + x - 1; } bool check(int x,int num) { int ans = f(x); if(ans\u0026gt;num) return false; else return true; } int erfen(int a,int b,int num) { while(a\u0026lt;b) { int mid = (a + b) / 2; if(check(mid,num)) { b = mid; } else{ a = mid + 1; } } return a; } void solve() { int l, r; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; int x = sqrt(n); int y=x*(2+x); if(y\u0026gt;n) { x--; } int ans = 0; if(l\u0026lt;=x) { if(r\u0026lt;=x) { int num = f(r); ans=erfen(l,r,num); } else{ int a = f(x); int b = f(x + 1); if(a\u0026gt;b) { ans = x+1; } else{ ans=erfen(l,x,a); } } } else { ans = l; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t = 1; cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } F/G.Tokitsukaze and Gold Coins (easy/hard) 1.迷宫（n*3）。迷宫起点（1，1），迷宫终点（n,3）每个格子都有一条向下和一条向右的单向道路。\n2.在迷宫的起点设有离开迷宫的出口，玩家可以通过出口安全的离开迷宫。 普通的Dfs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN = 5e5 + 5; #define int long long int n, k; int mt[MAXN][5]; int dx[] = { 0,1 }; int dy[] = { 1,0 }; int res = 0; bool dfs(int curx, int cury) {//传入当前坐标 if (curx == n \u0026amp;\u0026amp; cury == 3) {//如果当前坐标为终点，则返回true return 1; } else {//否则我们分别往右或者往下，如果有一条路能走，则返回true bool flag = 0; for (int i = 0; i \u0026lt; 2; i++) { int nx = dx[i] + curx; int ny = dy[i] + cury; if (nx \u0026lt;= n \u0026amp;\u0026amp; ny \u0026lt;= 3 \u0026amp;\u0026amp; mt[nx][ny] != -1) { if (mt[nx][ny] == 0) { flag = 1; continue; }//如果下一个点可以走到终点，那么这一个点一定可以走到终点,吧flag改为1 if (dfs(nx, ny)) {//dfs下一个点是否能走到终点 flag = 1; } } } if (flag == 0) mt[curx][cury] = -1;//如果这个点不能走到终点，那么这个点直接打为-1，以后不考虑 else { res ++; mt[curx][cury] = 0; } return flag; } } void solve() { res = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) {//初始化 for (int j = 1; j \u0026lt;= 3; j++) mt[i][j] = 1; } while (k--) {//做k次 int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; mt[x][y] = -1 * mt[x][y]; } dfs(1, 1);//dfs得到答案 cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; return; } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; } H.Tokitsukaze and K-Sequence 单独考虑算贡献率 1.长度为n的序列划分成k个子序列\n2.定义序列的值为这个序列中只出现一次的数字的个数 思路： 1.当某个数出现次数\u0026lt;=k的时候，随便找个子序列放，贡献为x 2.当某个数出现次数\u0026gt;k的时候，最后一个子序列放完所有的重复数字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long typedef long long LL; const int mod = 233333333; const int INF = 0x3f3f3f3f; #define Max 500100 void solve() { int n; cin \u0026gt;\u0026gt; n; int ans = 0; map\u0026lt;int, int\u0026gt; cnt; for (int i = 0; i \u0026lt; n; ++ i) { int x; cin \u0026gt;\u0026gt; x; cnt[x] ++; // 记录每个数出现的次数 } vector\u0026lt;int\u0026gt; d1(n + 1), d2(n + 1); for (auto [_, x] : cnt) { // x 为出现次数 d1[x] += x; // x \u0026lt;= k 的个数取 x d2[x - 1] ++; // x \u0026gt; k 的个数取 x - 1 } for (int i = 1; i \u0026lt;= n; ++ i) { d1[i] += d1[i - 1]; } for (int i = n - 1; i \u0026gt;= 0; -- i) { d2[i] += d2[i + 1]; } // d1[] x \u0026lt;= k 的个数取 x ， d2[] x \u0026gt; k 的个数取 x - 1 for (int i = 1; i \u0026lt;= n; ++ i) { auto ans = d1[i] + d2[i] * (i - 1); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } int main(){ int t; cin \u0026gt;\u0026gt; t; while (t --) { solve(); } return 0; } I.Tokitsukaze and Musynx 1.n个音符从屏幕的上方移动到下方\n2.当音符移动到判定线附近时点击音符，会获得一个判定分x。\n3.判定分在不同的值域区间可以获得不同的 SYNC.RATE\n4.在游戏中，玩家可以使用一个整数h来修正一轮游戏的所有判定分\nJ.Tokitsukaze and Sum of MxAb 思维题 ai和aj在数轴上的情况：\nai\u0026lt;0\u0026lt;aj max为ai到aj的距离 即，max为|ai|加|aj| 0\u0026lt;ai\u0026lt;aj max为ai加aj 即，max为|ai|加|aj| 0\u0026gt;ai\u0026lt;aj max为-ai加-aj 即，max为|ai|加|aj| 因为|ai|加|aj|=|aj|加|ai| 题目要求： 1 2 3 for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;n;j++) ans+=abs(a[i])+abs(a[j]); 从这个循环可以看出ai被加了2n次，因此被简化成下面：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long using namespace std; const ll N=1e6+100; int main(){ int t; cin\u0026gt;\u0026gt;t; while(t--){ int n; cin\u0026gt;\u0026gt;n; ll sum=0; for(int i=1;i\u0026lt;=n;i++){ ll a; cin\u0026gt;\u0026gt;a; sum+=2*n*abs(a); } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } } Day5 A. 解开束缚缠丝Ⅱ 1.构成的最长回文串的长度是多少\n2.分情况讨论，奇数的情况，偶数的情况\n3.分别统计每个字符出现的次数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; int n; int cnt[130]; int one = 0, ans = 0; //统计每个字母的数目。奇数有一个放中间，偶数直接放两边 LL jiejue() { cin \u0026gt;\u0026gt; n; for (int i = \u0026#39;a\u0026#39;; i \u0026lt;= \u0026#39;z\u0026#39;; ++i) { cnt[i] = 0; } for (int i = \u0026#39;A\u0026#39;; i \u0026lt;= \u0026#39;Z\u0026#39;; ++i) { cnt[i] = 0; } for (int i = 1; i \u0026lt;= n; ++i) { string x; cin \u0026gt;\u0026gt; x; cnt[x[0]]++; } one = ans = 0; for (int i = \u0026#39;A\u0026#39;; i \u0026lt;= \u0026#39;Z\u0026#39;; ++i) { if (cnt[i] % 2 != 0) { one = 1; ans += (cnt[i] - 1); } else ans += cnt[i]; } for (int i = \u0026#39;a\u0026#39;; i \u0026lt;= \u0026#39;z\u0026#39;; ++i) { if (cnt[i] % 2 != 0) { one = 1; ans += (cnt[i] - 1);//如果是一个的话就摆不好 } else ans += cnt[i]; } if(one==1){ cout \u0026lt;\u0026lt; ans +1 \u0026lt;\u0026lt; endl; } else{ cout\u0026lt;\u0026lt; ans\u0026lt;\u0026lt; endl; } } int main() { int t; cin\u0026gt;\u0026gt;t; while(t--){ jiejue(); } } B.7的意志 1.寻找区间能相加等于7777的\n2.用前缀和算出他们的前缀和，然后判断+7777的数是否在这个前缀和中\n3.若在，找出他的最小下标\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; const LL N=1e5+10; LL s[N]; LL a[N]; //输出一个整数代表有多少个不同的区间和为7777 LL jiejue() { int n; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;a[i]; s[i]=s[i-1]+a[i];//前缀和 } LL ans=0; for(int i=1;i\u0026lt;=n;i++){ LL tar = s[i - 1] + 7777;//左边 i-1 LL x = lower_bound(s + 1, s + n + 1, tar) - s;//右边x if (s[x] == tar) ++ans; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin\u0026gt;\u0026gt;t; while(t--){ jiejue(); } return 0; } I. 好想听肆宝唱歌啊 1.关键是结构体排序\n2.找到第k+1的歌曲名字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; int n; struct SONG { int w; string x; }s[100005];//结构体 bool operator\u0026lt;(const SONG \u0026amp;A, const SONG \u0026amp;B) { return A.w \u0026gt; B.w; };//自定义排序规则 void jiejue() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; s[i].w \u0026gt;\u0026gt; s[i].x; } sort(s + 1, s + n + 1); int k; cin \u0026gt;\u0026gt; k; cout \u0026lt;\u0026lt; s[k + 1].x\u0026lt;\u0026lt;endl; } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); LL t; //\tcin \u0026gt;\u0026gt; _; t= 1; while (t--) jiejue(); return 0; } J. 毁灭凤凰人 1.有两种情况下能将凤凰人除外\n2.送到墓地，再使用怪兽卡\n3.没送到墓地，使用「墓穴的指名者」\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; int n, m; int mxa = 0, a = 0, b = 0; void jiejue() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;//卡牌数量，毁灭凤凰人状态，0攻击1防守 for (int i = 1; i \u0026lt;= n; ++i) { int o, x; cin \u0026gt;\u0026gt; o;//卡牌种类。0状态附带攻击值 if (o == 0) { cin \u0026gt;\u0026gt; x; mxa = max(mxa, x);//只使用攻击值最大的卡牌 } else if (o == 1) a = 1;//1状态防守，使用完0卡将怪兽送走 else b = 1;//2状态直接送走 } if (m == 0 \u0026amp;\u0026amp; mxa \u0026gt;= 2500 \u0026amp;\u0026amp; a) {//凤凰人攻击 ，并且我们有1卡 cout \u0026lt;\u0026lt; \u0026#34;haoye\\n\u0026#34;; return; } else if (m == 1 \u0026amp;\u0026amp; mxa \u0026gt; 2100 \u0026amp;\u0026amp; a) {//凤凰人防守 ，并且我们有1卡 cout \u0026lt;\u0026lt; \u0026#34;haoye\\n\u0026#34;; return; } else if (b \u0026amp;\u0026amp; n \u0026gt;=2) {//只要保证n有两张以上的卡就可以直接送走 cout \u0026lt;\u0026lt; \u0026#34;haoye\\n\u0026#34;; return; } else cout \u0026lt;\u0026lt; \u0026#34;QAQ\\n\u0026#34;; } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); LL t; //\tcin \u0026gt;\u0026gt; t; t = 1; while (t--) jiejue(); return 0; } K. 欢迎来到杭师大 直接输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; string s; s=\u0026#34;Welcome to HZNU\u0026#34;; while(n--) { cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;endl; } } L. Ayanoto 变形记 任意一个大于0的数，进行有限次的相加绝对都会加到某个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; const LL N=1e5+10; LL n,x; //x长度,n个点 LL jiejue(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x; //看看是否能从0加到n int ans=0; if(x!=0) cout\u0026lt;\u0026lt;\u0026#34;yes\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;no\u0026#34;\u0026lt;\u0026lt;endl;\t} int main() { int t; cin\u0026gt;\u0026gt;t; while(t--){ jiejue(); } return 0; } M. P 龙学的教诲 1.每个单词每个单词的找，看标点是否在末尾\n2.按照规则输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; const LL N=2e5; LL n; string x[N]; char note; void print(int id) {//输出一整个单词 if (id != n) cout \u0026lt;\u0026lt; x[id];//不等于最后一个单词 else { int len = x[id].length(); for (int i = 0; i \u0026lt; len - 1; ++i) {//到len-2 cout \u0026lt;\u0026lt; x[id][i]; } } } LL jiejue() { //cin\u0026gt;\u0026gt;n; n=0; while (1) { cin \u0026gt;\u0026gt; x[++n]; //遇到空格看一下末尾有没有标点 int len = x[n].length(); if (x[n][len - 1] == \u0026#39;.\u0026#39;|| x[n][len - 1] == \u0026#39;!\u0026#39; or x[n][len - 1] == \u0026#39;?\u0026#39;) { note = x[n][len - 1];//标点存这 break;//找到标点直接break } } for (int i = 1; i \u0026lt;= n / 2; ++i) { print(i); //1~n/2 cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; print(n - i + 1);//n~n/2+1 if (i \u0026lt; n / 2 ||n % 2 == 1) cout \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } if (n % 2 == 1){ //如果是奇数，偶数的最后一个数就是他 print(n / 2 + 1); } cout \u0026lt;\u0026lt; note \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t; cin\u0026gt;\u0026gt;t;//t行若干单词 while(t--){ jiejue(); } return 0; } ","date":"2023-01-21T11:24:19+08:00","permalink":"https://IsQinna.github.io/p/2023%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83week2acm%E9%9B%86%E8%AE%AD/","title":"2023寒假训练week2（ACM集训）"},{"content":"Day1 蓝桥杯模拟赛 A [蓝桥杯 2020 省 AB1] 解码 连个限制条件： 1.将连续的几个相同字母写成字母 + 出现次数的形式 2.为了方便表达，小明不会将连续的超过9个相同的字符写成简写的形式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s; int main(){ cin\u0026gt;\u0026gt;s; for(int i=0; i\u0026lt;s.size(); i++){ if((s[i]\u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp; s[i]\u0026lt;=\u0026#39;z\u0026#39;) || (s[i]\u0026gt;=\u0026#39;A\u0026#39; \u0026amp;\u0026amp; s[i]\u0026lt;=\u0026#39;Z\u0026#39;)) cout \u0026lt;\u0026lt; s[i]; if(s[i]\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i]\u0026lt;=\u0026#39;9\u0026#39;){ //注意条件2，小于9 int k = s[i]-\u0026#39;1\u0026#39;; //将字符转换成数字 while(k--){ cout \u0026lt;\u0026lt; s[i-1];//s[i]是字符数字，s[i-1]是字母 } } } return 0; } B [蓝桥杯 2020 省 AB2] 成绩分析 计算最高分、最低分和平均分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; float sum=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); int maxx=-1; int minn=101; int num=n; while(n--){ int s; scanf(\u0026#34;%d\u0026#34;,\u0026amp;s); sum+=s; //求和 maxx=max(s,maxx); //最大值函数 minn=min(s,minn); //最小值函数 } printf(\u0026#34;%d\\n\u0026#34;,maxx); printf(\u0026#34;%d\\n\u0026#34;,minn); printf(\u0026#34;%.2f\\n\u0026#34;,sum/num); //平均数 } C [蓝桥杯 2020 省 B1] 整除序列 有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，请输出这个序列中值为正数的项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { long long n; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); printf(\u0026#34;%lld \u0026#34;,n); while(1){ if(n/2){ //如果!0除以二并输出 n/=2; printf(\u0026#34;%lld \u0026#34;,n); } //否则break else break; } return 0; } D [蓝桥杯 2020 省 AB3] 日期识别 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; using namespace std; string s; int main() { string mons[13]= {\u0026#34;\u0026#34;,\u0026#34;Jan\u0026#34;,\u0026#34;Feb\u0026#34;,\u0026#34;Mar\u0026#34;,\u0026#34;Apr\u0026#34;,\u0026#34;May\u0026#34;,\u0026#34;Jun\u0026#34;,\u0026#34;Jul\u0026#34;,\u0026#34;Aug\u0026#34;,\u0026#34;Sep\u0026#34;,\u0026#34;Oct\u0026#34;,\u0026#34;Nov\u0026#34;,\u0026#34;Dec\u0026#34;}; cin \u0026gt;\u0026gt; s; string mon,day; mon=s.substr(0,3); //月份的子串对应下标输出 day=s.substr(3); //日期的子串将字符数组转换成数字 for(int i = 1;i\u0026lt;13;i ++) if(mon== mons[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; int d = (day[0] - \u0026#39;0\u0026#39;) * 10 + (day[1] - \u0026#39;0\u0026#39;); //最多两位数 cout \u0026lt;\u0026lt;d; return 0; } E [蓝桥杯 2020 省 AB2] 回文日期 就是输出最近的回文日期 注意： 1.输出最近的一个回文日期 2.输出最近的一个ABABABAB型回文日期 3.啊啊啊啊啊啊，不知道为什么，不能用to_string()函数将数字转换成字符串 4.于是版本一因为用了to_string没过，只好自己写一个转换函数，见版本二,还是tmd不过，洛谷卡bug了？ 5.acwing两个版本都AC了，难道真的是洛谷的问题？ 版本一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int months[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31}; bool check(int date) //判断日期是否合法 { int year = date / 10000; int month = date % 10000 / 100; int day = date % 100; if(!day || month \u0026lt; 0 || month \u0026gt; 12 ) return false; if(month != 2 \u0026amp;\u0026amp; day \u0026gt;months[month]) return false; if(month == 2) { if((year%4==0\u0026amp;\u0026amp;year%100!=0)||(year%400==0)) //闰年特判 { if(day \u0026gt; 29) return false;\t//闰年2月29天 } else { if(day \u0026gt; 28) return false;\t//平年2月28天 } } return true; } bool check1(string s) //判断是否是回文日期 { int len = s.size(); for(int i = 0, j = len - 1; i \u0026lt; j ; i++,j--) //双指针 { if(s[i] != s[j]) return false; } return true; } bool check2(string s) //判断是否是ABABBABA 型的回文日期 { if(check1(s)) //首先该日期要满足回文格式 { if(s[0]!=s[2] || s[1]!= s[3] || s[0] == s[1]) return false; return true; } } int main() { int date,flag=0; cin\u0026gt;\u0026gt;date; for(int i = date + 1; ;i++) { if(check(i)) { string s = to_string(i); if(check1(s)\u0026amp;\u0026amp;!flag) //输出回文日期 { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; flag = 1; //标记一下，避免多次输出 } if(check2(s)) //输出ABABBABA 型的回文日期 { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return 0; } } } return 0; } 版本二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int months[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31}; bool check(int date) //判断日期是否合法 { int year = date / 10000; int month = date % 10000 / 100; int day = date % 100; if(!day || month \u0026lt; 0 || month \u0026gt; 12 ) return false; if(month != 2 \u0026amp;\u0026amp; day \u0026gt;months[month]) return false; if(month == 2) { if((year%4==0\u0026amp;\u0026amp;year%100!=0)||(year%400==0)) //闰年特判 { if(day \u0026gt; 29) return false; } else { if(day \u0026gt; 28) return false; } } return true; } bool check1(string s) //判断是否是回文日期 { int len = s.size(); for(int i = 0, j = len - 1; i \u0026lt; j ; i++,j--) //双指针 { if(s[i] != s[j]) return false; } return true; } bool check2(string s) //判断是否是ABABBABA 型的回文日期 { if(check1(s)) //首先该日期要满足回文格式 { if(s[0]!=s[2] || s[1]!= s[3] || s[0] == s[1]) return false; return true; } } int main() { int date,flag=0; cin\u0026gt;\u0026gt;date; for(int i = date + 1; ;i++) { if(check(i)) { string s; int in=i; for(int k=0;k\u0026lt;8;k++){//数字转换成字符串 s+=in%10+\u0026#39;0\u0026#39;; in/=10; } reverse(s.begin(),s.end()); if(check1(s)\u0026amp;\u0026amp;!flag) //输出回文日期 { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; flag = 1; //标记一下，避免多次输出 } if(check2(s)) //输出ABABBABA 型的回文日期 { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return 0; } } } return 0; } F[蓝桥杯 2020 省 B2] 平面切分 数学+去重\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1010; long double L[N][2];//存储A，B long long ans = 1; //初始一个平面 int main(){ int N; cin \u0026gt;\u0026gt; N; for(int i = 0;i \u0026lt; N;i++){ cin \u0026gt;\u0026gt; L[i][0] \u0026gt;\u0026gt; L[i][1]; bool flag = false; for(int j = 0;j \u0026lt; i;j++){//判断是否重边 if((L[j][0] == L[i][0]) \u0026amp;\u0026amp; (L[j][1] == L[i][1])){ flag = true; break; } } if(!flag){//若不重边,再判断交点数 set\u0026lt;pair\u0026lt;long double,long double\u0026gt; \u0026gt; points;//记录每一条边加进来后与已有直线相交的不同位置的点 for(int k = 0;k \u0026lt; i;k++){ if(L[k][0] == L[i][0]) continue;//斜率相同永远没有交点 //求交点 long double x = (L[i][1]-L[k][1])/(L[k][0]-L[i][0]); long double y = L[i][0]*x+L[i][1]; points.insert(make_pair(x,y));//将x，y放进set中排序，自动去重 } ans += points.size()+1; } } cout \u0026lt;\u0026lt; ans; return 0; } G [蓝桥杯 2020 省 AB1] 走方格 比普通的dp多了一个限制条件，i和j均为偶数的时候，dp[i][j]=0//也就是不变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; long long dp[1000][1000];\t//走到n,m的方法数 int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++) dp[i][1]=1; for(int i=1;i\u0026lt;=m;i++) dp[1][i]=1; for(int i=2;i\u0026lt;=n;i++){ for(int j=2;j\u0026lt;=m;j++){ if(i%2==0\u0026amp;\u0026amp;j%2==0) //i和j均为偶数的时候，dp[i][j]=0也就是不变 continue; dp[i][j]=dp[i][j-1]+dp[i-1][j];\t} } cout\u0026lt;\u0026lt;dp[n][m]\u0026lt;\u0026lt;endl; return 0; } H [蓝桥杯 2020 省 AB3] 乘法表 1.输出整齐的表格\n2.进制转换（这是重点）——十分不幸的是，C++的进制转换库函数不能用，不过，自己动手丰衣足食嘛！\n3.P 进制中大于等于 10 的数字用大写字母 A、B、C、··· 表示。这点万分重要因为我在比赛的时候没有看见这句换，只用了1，2条件，于是只得了30分emmm\n4.等号左边大于等于10的数要用A，B，C\u0026hellip;来替代,等号右边P进制数中大于等于10的数也要用A，B，C\u0026hellip;来替代。\nDay2 Dfs 1.回溯-\u0026gt;出栈\n2.递归-\u0026gt;入栈 递归过程使用系统自带栈，因此我们不需要自己手写栈，只需要写递归程序即可\n迷宫问题 找有多少条线路\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; /* 2 2 1 1 1 2 2 1 2 */ const int N=100; int sx,sy,fx,fy; bool g[N][N]; bool mapp[N][N]; int d[]={-1,0,1,0,-1}; int ans=0; int n,m,t; void dfs(int x,int y){ if(x==fx\u0026amp;\u0026amp;y==fy){ ans++; return; } for(int k=0;k\u0026lt;4;k++){ int l,r; l=x+d[k],r=y+d[k+1]; //注意：这不能用x+=因为x是局部变量。值的改变导致if判断出错 if(l\u0026gt;=1\u0026amp;\u0026amp;r\u0026gt;=1\u0026amp;\u0026amp;l\u0026lt;=n\u0026amp;\u0026amp;r\u0026lt;=m\u0026amp;\u0026amp;!g[l][r]\u0026amp;\u0026amp;!mapp [l][r])//防止数组越界,且不能走到障碍 { mapp[l][r]=true; dfs(l,r); mapp[l][r]=false; } } return ; } int main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;t; cin\u0026gt;\u0026gt;sx\u0026gt;\u0026gt;sy\u0026gt;\u0026gt;fx\u0026gt;\u0026gt;fy; while(t--){ int gx,gy; cin\u0026gt;\u0026gt;gx\u0026gt;\u0026gt;gy; g[gx][gy]=true;//有障碍 } /* for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ cout\u0026lt;\u0026lt;g[i][j];\t} cout\u0026lt;\u0026lt;endl;\t} */ mapp[sx][sy]=true;//标记为已走过 dfs(sx,sy); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } n皇后问题 1.一行一行的递归 2.主对角线不行（x-y+n），副对角线不行(x+y)，竖线不行(x)，横线不行(y)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=100; int pos[N]; int tot=0; int n;\t//棋盘大小 bool vis[3][N]; void dfs(int u){ if(u==n)//到第n行的时候 { for(int i=0;i\u0026lt;n;i++)//输出 for(int j=0;j\u0026lt;n;j++){ if(pos[i]==j) cout\u0026lt;\u0026lt;\u0026#39;Q\u0026#39;;//pos记录每一行皇后放在哪个位子 else cout\u0026lt;\u0026lt;\u0026#39;*\u0026#39;; if(j==n-1) cout\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;endl; tot++;//记结果有几个 } else { for(int i=0;i\u0026lt;n;i++){ if(!vis[0][i]\u0026amp;\u0026amp;!vis[1][u+i]\u0026amp;\u0026amp;!vis[2][u-i+n]) //vis的第一个维度取0表示当前位 取1表示主对角线 取2表示副对角线 { pos[u]=i;//第u行第i列放不放皇后 vis[0][i]=vis[1][u+i]=vis[2][u-i+n]=true; dfs(u+1); vis[0][i]=vis[1][u+i]=vis[2][u-i+n]=false; } } } } int main() { cin\u0026gt;\u0026gt;n; dfs(0);//第一行开始 return 0; } 求细胞数量 细胞的定义为沿细胞数字上下左右若还是细胞数字则为同一细胞\n0~9表示细胞\n求给定矩形阵列的细胞个数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=105; int n,m; char g[N][N]; int dx[]={-1,0,1,0}; int dy[]={0,1,0,-1}; bool st[N][N];//false没走过 /* 4 10 0234500067 1034560500 2045600671 0000000089 */ void dfs(int x,int y){ st[x][y]=true;//标记走过 for(int k=0;k\u0026lt;4;k++){ int l,r; l=x+dx[k],r=y+dy[k]; if(l\u0026gt;=0\u0026amp;\u0026amp;r\u0026gt;=0\u0026amp;\u0026amp;l\u0026lt;n\u0026amp;\u0026amp;r\u0026lt;m\u0026amp;\u0026amp;g[l][r]!=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;st[l][r]!=true){ dfs(l,r); } } return; } int main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++){ scanf(\u0026#34;%s\u0026#34;,g[i]);\t} /* for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ cout\u0026lt;\u0026lt;g[i][j];\t} cout\u0026lt;\u0026lt;endl; } */\tint ans=0; for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;m;j++){ if(g[i][j]!=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;st[i][j]!=true){ dfs(i,j); ans++; } } /*\tcout\u0026lt;\u0026lt;\u0026#34;--------------\u0026#34;\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ cout\u0026lt;\u0026lt;st[i][j];\t} cout\u0026lt;\u0026lt;endl; } */ cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } Day3 SMU Winter 2023 Round #3 (Div.2) A [eJOI2019] 异或橙子 B [传智杯 #4 决赛] 三元组 找出n之前的：i+j=k\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; //有序好耶 int main(){ int t,n,s[105],ans=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); while(t--){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;s[i]); } for(int i=1;i\u0026lt;=n;i++){\t//依次遍历1~n for(int j=i;j\u0026lt;=n;j++){\t//依次遍历i~n for(int k=j;k\u0026lt;=n;k++){\t//依次遍历j~n if(s[k]==s[i]+s[j]){ ans++; } } } } printf(\u0026#34;%d\\n\u0026#34;,ans); ans=0; } } C [传智杯 #3 练习赛] 单位转换 1.全都转换成B 2.再将B转化成对应的进制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; //先将其转化为B，再转化为相应的第二个单位 string s; double sum=0; int main() { int i; cin\u0026gt;\u0026gt;s; while(s[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39;) { sum = sum * 10 + s[i] - \u0026#39;0\u0026#39;; i++; } if(s[i] == \u0026#39;M\u0026#39;) sum *= pow(2, 20);\t//1MB=2^20B else if(s[i] == \u0026#39;G\u0026#39;)\tsum *= pow(2, 30);\t//1GB=2^10B else if(s[i] == \u0026#39;K\u0026#39;) sum *= pow(2, 10);\t//KB=2^10B if(s[s.size() - 2] == \u0026#39;G\u0026#39;)\t//1B=2^(-30)GB sum *= pow(2, -30); else if(s[s.size() - 2] == \u0026#39;M\u0026#39;)\t//1B=2^(-20)MB sum *= pow(2, -20); else if(s[s.size() - 2] == \u0026#39;K\u0026#39;)\t//1B=2^(-10)KB sum *= pow(2, -10); printf(\u0026#34;%.6lf\u0026#34;,sum); } D [CSP-J 2022] 乘方 用pow函数即可\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main() { ll a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; ll c=pow(a,b); if(c\u0026gt;1e9||c\u0026lt;0) cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl; return 0; } E [CSP-J2020] 直播获奖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int arr[605] = {0};//数组这样开已经默认帮我们从大到小排序 int main(){ int n, w; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; w; for(int i = 1; i \u0026lt;= n; i++){ int a; cin \u0026gt;\u0026gt; a; arr[a]++;//这个分数有几人 //printf(\u0026#34;a[%d]=%d \u0026#34;,a,arr[a]); int num=max(1,i*w/100); //cout\u0026lt;\u0026lt;\u0026#34;num:\u0026#34;\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl; int cnt=0; for(int j=600;j\u0026gt;=0;j--){ cnt+=arr[j];//目前有几人 if(cnt\u0026gt;=num){ cout\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; \u0026#34;;//每加入一个人就去判断分数线 break; } } } cout \u0026lt;\u0026lt; endl; return 0; } F [NWRRC2014]Grave 判断能否塞进这个长方形 只要这个正方形环能装下就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a,b,c,d,e,f,g,h,x,y; int main(){ scanf(\u0026#34;%d%d%d%d%d%d%d%d%d%d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c,\u0026amp;d,\u0026amp;e,\u0026amp;f,\u0026amp;g,\u0026amp;h,\u0026amp;x,\u0026amp;y); if(c-g\u0026gt;=x\u0026amp;\u0026amp;d-b\u0026gt;=y){ printf(\u0026#34;Yes\\n\u0026#34;); return 0; } else if(e-a\u0026gt;=x\u0026amp;\u0026amp;d-b\u0026gt;=y){ printf(\u0026#34;Yes\\n\u0026#34;); return 0; } else if(c-a\u0026gt;=x\u0026amp;\u0026amp;f-b\u0026gt;=y){ printf(\u0026#34;Yes\\n\u0026#34;); return 0; } else if(c-a\u0026gt;=x\u0026amp;\u0026amp;d-h\u0026gt;=y){ printf(\u0026#34;Yes\\n\u0026#34;); return 0; } printf(\u0026#34;No\\n\u0026#34;); return 0; } G [CERC2013] Bus 1.递归 2.递推 递归：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; //递推公式：f(k-1)=f(k)*2+1; int n; int f(int x){ if(x==n) return 0; else return f(x+1)*2+1; } int main() { int k; cin\u0026gt;\u0026gt;k; while(k--){ cin\u0026gt;\u0026gt;n; cout\u0026lt;\u0026lt;f(0)\u0026lt;\u0026lt;endl; } return 0; } 递推：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int t; int k; int n; int main() { cin\u0026gt;\u0026gt;t; while(t--) { n=0;//将n清0 cin\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=k;i++) { n*=2;//将下车后剩下的人数乘2 n++;//再将n+1 } cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl;//输出n } return 0; } H [NWRRC2014]Alarm Clock 1.将“：”前的数记为i，后的数记为j 2.注意前导零，输出的时候需要进行判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n; int num[]={6, 2, 5, 5, 4, 5, 6, 3, 7, 6};//下标的火柴数目 int main(){ cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;24;i++){ for(int j=0;j\u0026lt;60;j++){ int a=i/10,b=i%10,c=j/10,d=j%10;//个十百千位 if((num[a]+num[b]+num[c]+num[d])==n){//相加是否等于n if(i\u0026lt;10) printf(\u0026#34;0%d\u0026#34;,i);//前导零的输出 else printf(\u0026#34;%d\u0026#34;,i); cout\u0026lt;\u0026lt;\u0026#34;:\u0026#34;; if(j\u0026lt;10) printf(\u0026#34;0%d\u0026#34;,j); else printf(\u0026#34;%d\u0026#34;,j); return 0; } } } cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;; return 0; } I [NOIP2005 普及组] 采药 01背包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e5; int main() { int t,m; cin\u0026gt;\u0026gt;t\u0026gt;\u0026gt;m; int ti[N],va[N]; for(int i=0;i\u0026lt;m;i++){ cin\u0026gt;\u0026gt;ti[i]; cin\u0026gt;\u0026gt;va[i]; } int dp[N]; dp[0]=0;\t//时间为0，价值为0\tfor(int i=0;i\u0026lt;m;i++)//草药 for(int j=t;j\u0026gt;=ti[i];j--){//时间 dp[j]=max(dp[j],dp[j-ti[i]]+va[i]); } cout\u0026lt;\u0026lt;dp[t]\u0026lt;\u0026lt;endl; } J 区间内的真素数 1.求素数——筛法 2.真素数——将数字反转，判断是否素数 3.数据范围1e5，直接先求出这个范围的所有素数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; //区间之间 const int N=1e5+5; bool a[N]; int ch(int n){//倒序 int sum=0; while(n){ sum=sum*10+n%10; n/=10; } return sum; } int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;//先将所有的1~1e5素数标记 for(int i=0;i\u0026lt;=N;i++) a[i]=true;//筛法求素数 for(int i=2;i\u0026lt;=sqrt(N);i++){ if(a[i]){ for(int j=i*i;j\u0026lt;=N;j+=i){ a[j]=false; }\t} } /*\tfor(int i=n;i\u0026lt;=m;i++){ if(a[i]==true) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } */ int cnt=0; for(int i=n;i\u0026lt;=m;i++){ if(a[i]\u0026amp;\u0026amp;a[ch(i)]){ if(cnt==0) printf(\u0026#34;%d\u0026#34;,i); if(cnt){ printf(\u0026#34;,%d\u0026#34;,i);\t} cnt++; } } if(cnt==0) cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; return 0; } K 素数回文数的个数 1.跟上一题思路一样，直接求出范围内的所有素数 2.判断是否回文数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1e4+10; bool a[N]; //左右对称的素数 bool check(int n){ string s; while(n)\t//数字转换成字符串 { s+=n%10+\u0026#39;0\u0026#39;; n/=10; } //cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; \u0026#34;; reverse(s.begin(),s.end());//翻转 //cout\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //cout\u0026lt;\u0026lt;s.size()\u0026lt;\u0026lt;endl; for(int i=0,j=s.size()-1;i\u0026lt;j;i++,j--){//双指针判断是否回文 //cout\u0026lt;\u0026lt;s[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;s[j]\u0026lt;\u0026lt;endl; if(s[i]!=s[j]) return false; } return true; } int main() { int n; cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;=N;i++) a[i]=true;//筛法求素数 for(int i=2;i\u0026lt;=sqrt(N);i++){ if(a[i]){ for(int j=i*i;j\u0026lt;=N;j+=i){ a[j]=false; }\t} } /* for(int i=11;i\u0026lt;=n;i++) if(a[i]) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; */ int cnt=0; for(int i=11;i\u0026lt;=n;i++){ if(check(i)\u0026amp;\u0026amp;a[i]){ cnt++; } } cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; } Day5 SMU Winter 2023 Round #4 (Div.2) A.Chuanpai 数据范围x和y的范围是16 因此最大的牌面只能是12 直接枚举112就OK\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; //x\u0026lt;=6,y\u0026lt;=6 int main() { int t; cin\u0026gt;\u0026gt;t; while(t--){ int x; cin\u0026gt;\u0026gt;x; if(x\u0026gt;12){//大于12 cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; } else {//1~12 if(x==12||x==11){ cout\u0026lt;\u0026lt;\u0026#39;1\u0026#39;\u0026lt;\u0026lt;endl; } if(x==10||x==9) cout\u0026lt;\u0026lt;\u0026#39;2\u0026#39;\u0026lt;\u0026lt;endl; if(x==8) { cout\u0026lt;\u0026lt;\u0026#39;3\u0026#39;\u0026lt;\u0026lt;endl; } if(x\u0026lt;=7){ cout\u0026lt;\u0026lt;x/2\u0026lt;\u0026lt;endl; }\t}\t} return 0; } B.Hotpot m次操作两个人轮流，第二个喜欢吃同样食物的人加m/2次幸福值，第一个人永远是0 那么我们就可以将两轮看做一个循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; const int N=1e5+10; struct f{ int x;//每个人喜欢的食物 int happy;//每个人的快乐值 }a[N]; int v[N];//用来记录锅子里有没有这个食材 long long n,k,m; int main() { int t; cin\u0026gt;\u0026gt;t; while(t--) { memset(v,0,sizeof(v)); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;a[i].x; a[i].happy=0; } if(m\u0026gt;=2*n) { for(int i=0;i\u0026lt;2*n;i++) { int j=i%n; if(v[a[j].x]==0){//锅子里没有喜欢的食材 v[a[j].x]++;//放进食材 }else{//锅子里有喜欢的食材 v[a[j].x]--;//吃掉 a[j].happy++;//他快乐了 } } for(int i=0;i\u0026lt;n;i++) a[i].happy*=(m/(2*n));//以2*n为一次循环，有几次循环就让快乐值乘几 } for(int i=0;i\u0026lt;m%(2*n);i++)//剩下的操作次数 { int j=i%n; if(v[a[j].x]==0)v[a[j].x]++; else { v[a[j].x]--; a[j].happy++; } } for(int i=0;i\u0026lt;n;i++) { if(i)cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;a[i].happy; } cout\u0026lt;\u0026lt;endl; } return 0; } C.Triangle Pendant D. Rock Paper Scissors 石头剪刀布游戏，让后出的那个人分数最大\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; long long b1, b2, b3, d1, d2, d3, t; int main() { ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); cin \u0026gt;\u0026gt; t; while(t -- ) { cin \u0026gt;\u0026gt; b1 \u0026gt;\u0026gt; b2 \u0026gt;\u0026gt; b3 \u0026gt;\u0026gt; d1 \u0026gt;\u0026gt; d2 \u0026gt;\u0026gt; d3; long long ans = 0; if(b1 \u0026lt;= d2) { ans += b1; d2 -= b1; b1 = 0; if(b2 \u0026lt;= d3) { ans += b2; d3 -= b2; b2 = 0; if(b3 \u0026lt;= d1) { ans += b3; d1 -= b3; b3 = 0; } else if(b3 \u0026gt; d1) { ans += d1; b3 -= d1; d1 = 0; } } else if(b2 \u0026gt; d3) { ans += d3; b2 -= d3; d3 = 0; if(b3 \u0026lt;= d1) { ans += b3; d1 -= b3; b3 = 0; } if(b3 \u0026gt; d1) { ans += d1; b3 -= d1; d1 = 0; }\t} } else if(b1 \u0026gt; d2) { ans += d2; b1 -= d2; d2 = 0; if(b2 \u0026lt;= d3) { ans += b2; d3 -= b2; b2 = 0; if(b3 \u0026lt;= d1) { ans += b3; d1 -= b3; b3 = 0; } else if(b3 \u0026gt; d1) { ans += d1; b3 -= d1; d1 = 0; } } else if(b2 \u0026gt; d3) { ans += d3; b2 -= d3; d3 = 0; if(b3 \u0026lt;= d1) { ans += b3; d1 -= b3; b3 = 0; } else if(b3 \u0026gt; d1) { ans += d1; b3 -= d1; d1 = 0; }\t}\t} long long aa = d1, bb = d2, cc = d3; d1 = d1 - min(d1,b1); d2 = d2 - min(d2,b2); d3 = d3 - min(d3,b3); b1 = b1 - min(aa,b1); b2 = b2 - min(bb,b2); b3 = b3 - min(cc,b3); long long sum = d1 + d2 + d3 + b1 + b2 + b3; sum /= 2; ans -= sum; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } E.Don’t Really Like How The Story Ends F.Direction Setting G. Hourly Coding Problem H.Nihongo wa Muzukashii Desuz 字符串匹配和转换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; /* 10 machimasu kaerimasu nomimasu yobimasu shinimasu kakimasu ikimasu kikimasu isogimasu kashimasu */ int main() { int t; cin \u0026gt;\u0026gt; t; while(t -- ) { string s; cin \u0026gt;\u0026gt; s; int len = s.length(); // cout \u0026lt;\u0026lt; \u0026#34;!!!!!!!!\u0026#34;; if(len \u0026lt;=5) cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; else if(s == \u0026#34;ikimasu\u0026#34; ) cout \u0026lt;\u0026lt; \u0026#34;itte\\n\u0026#34;; else if(len == 6) { if(s == \u0026#34;gimasu\u0026#34;)\tcout \u0026lt;\u0026lt; \u0026#34;ide\u0026#34; \u0026lt;\u0026lt; endl; else if(s == \u0026#34;kimasu\u0026#34;)\tcout \u0026lt;\u0026lt; \u0026#34;ite\u0026#34; \u0026lt;\u0026lt; endl; else if(s == \u0026#34;mimasu\u0026#34; || s == \u0026#34;bimasu\u0026#34; || s == \u0026#34;nimasu\u0026#34;)\tcout \u0026lt;\u0026lt; \u0026#34;nde\u0026#34; \u0026lt;\u0026lt; endl; else if(s == \u0026#34;rimasu\u0026#34;) cout \u0026lt;\u0026lt; \u0026#34;tte\u0026#34; \u0026lt;\u0026lt; endl; } else if(len \u0026gt;= 7) { string s1 = s.substr(len - 7, 7); string s2 = s.substr(len - 6, 6); if(s1 == \u0026#34;shimasu\u0026#34;) cout \u0026lt;\u0026lt; s.substr(0,len - 7) \u0026lt;\u0026lt; \u0026#34;shite\\n\u0026#34;; else if(s1 == \u0026#34;chimasu\u0026#34;) cout \u0026lt;\u0026lt; s.substr(0,len - 7) \u0026lt;\u0026lt; \u0026#34;tte\\n\u0026#34;; else if(s2 == \u0026#34;gimasu\u0026#34;) cout \u0026lt;\u0026lt; s.substr(0,len - 6) \u0026lt;\u0026lt; \u0026#34;ide\\n\u0026#34;; else if(s2 == \u0026#34;kimasu\u0026#34;) cout \u0026lt;\u0026lt; s.substr(0,len - 6) \u0026lt;\u0026lt; \u0026#34;ite\\n\u0026#34;; else if(s2 == \u0026#34;mimasu\u0026#34; || s2 == \u0026#34;bimasu\u0026#34; || s2 == \u0026#34;nimasu\u0026#34;) cout \u0026lt;\u0026lt; s.substr(0,len - 6) \u0026lt;\u0026lt; \u0026#34;nde\\n\u0026#34;; else if(s2 == \u0026#34;rimasu\u0026#34;) cout \u0026lt;\u0026lt; s.substr(0,len - 6) \u0026lt;\u0026lt; \u0026#34;tte\\n\u0026#34;; } } return 0; } I.Monster Hunter J. Ants K. K-skip Permutation L. Spicy Restaurant M.True Story 这题主要注意到从hour0开始，然后初始的时候飞机有一个始发时间 如果在最大的时间长度内跑，能到的人数就是最后能到机场不迟到的人数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include\u0026lt;bits/stdc++.h\u0026gt; /* case1: 4 3 10 4 1 5 2 1 3 4 5 7 9 10 */ using namespace std; const long long N=2e5; long long s[N]; long long t[N]; long long p[N]; //推迟时间-通知时间=能冲时间 //按能冲时间排序，能冲时间依次减小，就让速度最大的来试试？ //能冲时间*最大速度\u0026gt;=他们之间的距离 int main() { long long n,k,x,p0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;x\u0026gt;\u0026gt;p0; for(long long i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;s[i]; } for(long long i=1;i\u0026lt;=k;i++){ cin\u0026gt;\u0026gt;t[i]; } for(int i=1;i\u0026lt;=k;++i){ cin\u0026gt;\u0026gt;p[i]; p[i]-=t[i]; p0=max(p0,p[i]);//找最大时间间隔 } //\tif(s[0]*p0\u0026gt;=x) ans++;//0开始跑 int ans=0; for(int i=1;i\u0026lt;=n;++i) if(s[i]*p0\u0026gt;=x) ans++; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; return 0; } ","date":"2023-01-15T16:46:19+08:00","permalink":"https://IsQinna.github.io/p/2023%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83week1acm%E9%9B%86%E8%AE%AD/","title":"2023寒假训练week1（ACM集训）"},{"content":"Day1 蓝桥杯模拟赛 A.带分数 题意大致是用[1,9]之间的数来构造一个带分数，而且[1,9]必须每个都出现一次 这不就是全排列吗？ 1.我们可以用c++的stl函数，也可dfs深搜 2.将这个全排列函数分成三个部分，整数部分，分子部分，分母部分 3.不要求输出构造的函数，只要求输出结果总数ans 贪图省事的 Qinna用了最简单的库函数法。 方法一：net_permutation()函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a[10]={0,1,2,3,4,5,6,7,8,9}; int make_num(int x,int y)\t//将下标为x~y的数字连成y-x位的整数 { int sum=0; for(int i=x;i\u0026lt;=y;i++) sum=sum*10+a[i]; return sum; } int main() { int n,ans=0; cin\u0026gt;\u0026gt;n; do{ for(int i=1;i\u0026lt;=7;i++)\t//题目给出的范围10^6，整数最多6位 { for(int j=i+1;j\u0026lt;=8;j++)\t//分子的数最多7位 { int num1=make_num(1,i);//整数 int num2=make_num(i+1,j);//分子 int num3=make_num(j+1,9);//分母 if(num1+(num2/num3)==n\u0026amp;\u0026amp;(num2%num3==0)) ans++; }\t} }while(next_permutation(a+1,a+10)); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } B.错误票据 录入 ID 号的时候发生了一处错误，造成了某个 ID 断号，另外一个 ID 重号,找出断号的 ID 和重号的 ID。 这题不难，主要是要想到将所有数存起来…… 有两种方法： 第一种稍显麻烦，需要考虑换行和空格 第二种虽然也需要考虑，但是很巧妙,因为输入一个数后面必然要跟着一个空格或者换行 Qinna太笨了，比赛的时候只想到第一种。 方法一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a[100000] = {0}; int main(){ int n=0,pos=0; cin\u0026gt;\u0026gt;n; while(n--) { while(cin\u0026gt;\u0026gt;a[pos]) //用cin.get()吸收回车和换行 { pos++; if(cin.get()==\u0026#39;\\n\u0026#39;) //当cin.get()等于回车的时候读下一行数据 break; } } sort(a,a+pos); int re,cr; for(int i = 0; i \u0026lt; pos; i++) { if(a[i] == a[i+1]) re= a[i]; else if(a[i+1]-a[i] == 2) cr= a[i]+1; } cout\u0026lt;\u0026lt;cr\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;re; return 0; } 方法二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a[100000] = {0}; int main(){ int n=0,pos=0; cin\u0026gt;\u0026gt;n; while(cin\u0026gt;\u0026gt;m){ //读到结尾就自动结束了 a[pos++]=m; } sort(a,a+pos); int re,cr; for(int i = 0; i \u0026lt; pos; i++) { if(a[i] == a[i+1]) re= a[i]; else if(a[i+1]-a[i] == 2) cr= a[i]+1; } cout\u0026lt;\u0026lt;cr\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;re; return 0; } C.翻硬币 每次只能同时翻转相邻的两个硬币，求最小操作步数。 找到不同的就翻这枚和下一枚就好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s1,s2; int main() { cin\u0026gt;\u0026gt;s1\u0026gt;\u0026gt;s2; int sum=0; for(int i=0;i\u0026lt;s1.length()-1;i++) { if(s1[i]!=s2[i]) { sum++; s1[i]=s2[i]; if(s1[i+1]==\u0026#39;*\u0026#39;) s1[i+1]=\u0026#39;o\u0026#39;; else s1[i+1]=\u0026#39;*\u0026#39;; } } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } D.灵能传输 古怪的题目，求max（s[i]-s[i-1])最小 1.前缀和 2.贪心 3.排序 这题愣是没搞懂怎么写，之前没了解过前缀和，因此只好把前缀和的代码奉上了 求[l,r]的和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const long long N=100005; long long a[N]; long long s[N]; long long m,n; int main() { scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(long long i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); for(long long i=1;i\u0026lt;=n;i++) s[i]=s[i-1]+a[i]; while(m--){ long long l,r; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;l,\u0026amp;r); printf(\u0026#34;%lld\\n\u0026#34;,s[r]-s[l-1]); } return 0;\t} E.后缀表达式 首先我们得了解负号是可以相互抵消的，一个负号和很多个负号的效果其实是一样的 1.没有负号时，直接相加 2.有负号时： 可以表示成这样： （……+……+……)-(……+……+……)； //负号为奇数时 或者这样： （……+……+……)-(……+……-……)； //负号为偶数时 因此，只要最大的数-最小的数+其他数绝对值就OK\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long LL; const int MAXN=1e5+10; int n,m,k; LL a[2*MAXN]; int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m); k=n+m+1; for(int i=1;i\u0026lt;=k;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); LL sum=0; if(!m){ for(int i=1;i\u0026lt;=k;i++) sum+=a[i]; printf(\u0026#34;%lld\\n\u0026#34;,sum); return 0; } sort(a+1,a+k+1); sum+=a[k];sum-=a[1];m--; for(int i=2;i\u0026lt;k;i++) sum+=abs(a[i]); printf(\u0026#34;%lld\\n\u0026#34;,sum); return 0; } F.等差数列 这题很具有迷惑性格，一开始我以为公差是最小的就好了，但是如果有四个数，差值为2，3。我们不能取2作为公差，因为中间无论插入什么数，都不能构成等差数列。\n因此，正确的想法应该是求后面各项与第一项所有差值的最大公约数，这样能保证数列中的数最少，并且一定能构成等差数列。\n最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个。\n例如： 2，3的最大公因数是1，因此公差为1 c++库函数中有个专门求最大公约数的函数__gcd()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=1000010; int a[N]; int main(){ int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 0; i \u0026lt; n; i ++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } sort(a, a + n); //求后面各项与第一项所有差值的最大公约数 int d = 0; for(int i = 1; i\u0026lt;n;i++) d=__gcd(d,a[i]-a[0]); if(!d) printf(\u0026#34;%d\\n\u0026#34;, n); else printf(\u0026#34;%d\\n\u0026#34;, (a[n-1]-a[0])/d+1); return 0; } G.特别数的和 直接按照题目要求把数给拆分判断就OK\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool Is(int x){ int t; while(x){ t=x%10; if (t== 2||t==0||t==9||t==1) return true; else x/=10; } return false; } int main(){ int n; cin\u0026gt;\u0026gt;n; int sum=0; for(int i= 1;i\u0026lt;=n;++ i){ if(Is(i)) sum +=i; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; return 0 ; } H.完全二叉树的权值 就是一个模拟题，一层一层的算。确定每一层的头和尾，记录深度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a[100005]; int main() { int n; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i]; int maxd=0;//记最大的那层深度为maxd long long max=-100005;//记最大深度 //每层第一个数i是2的n次方 //每层最后一个数为下一层的前一个数。 int d=1; for(int i=1;i\u0026lt;=n;i*=2,d++) { long long sum=0; for(int j=i;j\u0026lt;=2*i-1\u0026amp;\u0026amp;j\u0026lt;=n;j++) { sum+=a[j]; } if(sum\u0026gt;max)\t//找到最大的那层 { max=sum; maxd=d; } } cout\u0026lt;\u0026lt;maxd\u0026lt;\u0026lt;endl; } Day2 二分法补题 分巧克力 每个小朋友至少1x1 输出切出的正方形巧克力最大可能的边长。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int const N = 100010; int w[N], h[N];//存储长、宽 int n, k; bool chack(int a) { int num = 0;//记录分成长度为 a 的巧克力数量 for (int i = 0; i \u0026lt; n; i++) { num += (w[i] / a) * (h[i] / a);//每一大块可以分成的边长为 a 的巧克力数量 if (num \u0026gt;= k) return true;//大于要求数量，返回真 } return false; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; h[i] \u0026gt;\u0026gt; w[i]; int l = 1, r = 1e5;//小巧克力数量边长一定在 1 -- 100000 之间 while (l \u0026lt; r)//二分小巧克力边长范围，找到符合要求的最大值 { int mid = l + (r - l + 1 \u0026gt;\u0026gt; 1);//因为l = mid ，所以 mid 取 l + r + 1 \u0026gt;\u0026gt; 1,为了防止加和越界，改写成 l + (r - l + 1 \u0026gt;\u0026gt; 1) if (chack(mid)) l = mid; else r = mid - 1; } cout \u0026lt;\u0026lt; r; } Day3 SMU Winter 2023 Round #1 (Div.2)~ACM A.不可以，总司令 满足条件输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n,y; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;y; if(n\u0026gt;y){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; } else if(n\u0026lt;y){ cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; } else{ cout\u0026lt;\u0026lt;\u0026#34;equal probability\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } B.计算 将三位数拆分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { long long n; cin\u0026gt;\u0026gt;n; long long ge,shi,bai; ge=n%10; bai=n/100; shi=n/10%10; long long sum1,sum2,sum3; sum1=ge+shi+bai; cout\u0026lt;\u0026lt;sum1\u0026lt;\u0026lt;endl; sum2=sum1*sum1; cout\u0026lt;\u0026lt;sum2\u0026lt;\u0026lt;endl; sum3=sum1*sum1*sum1; cout\u0026lt;\u0026lt;sum3\u0026lt;\u0026lt;endl; return 0; } C.拱猪计分 考察细心和耐力的题目，写到吐血 发现一个很有用的库函数pair\u0026lt;T,T\u0026gt;,对付拱猪计分的那题非常有帮助\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; char s[5]; const int shuzilue[16]={0,-50,-2,-3,-4,-5,-6,-7,-8,-9,-10,-20,-30,-40,-100,+100}; struct shabi { char fl;//花色 int shuzi;//数字 } f[5][21]; int sum[5]; int main() { while (1) { memset(f,0,sizeof(f)); memset(sum,0,sizeof(sum)); bool flag=true;//是否文件结束 for (int i=1;i\u0026lt;=4;i++) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); if (n!=0) flag=false; for (int j=1;j\u0026lt;=n;j++) { scanf(\u0026#34;%s\u0026#34;,s);\t//字符串 f[i][j].fl=s[0];\t//花色 f[i][j].shuzi=s[1]-48;\t//数字 if (strlen(s)==3) f[i][j].shuzi=f[i][j].shuzi*10+s[2]-48;//最多两位数 if (f[i][j].fl==\u0026#39;C\u0026#39;) f[i][17].shuzi++;//花色数量 else if (f[i][j].fl==\u0026#39;S\u0026#39;) f[i][18].shuzi++; else if (f[i][j].fl==\u0026#39;D\u0026#39;) f[i][19].shuzi++; else f[i][20].shuzi++; } if (n==0) {sum[i]=0;continue;}//若未持有这 1616 张牌之任一张则以得零分计算 if (n==16) {sum[i]=1000;continue;}//若有一玩家持有所有 16 张计分牌，则得 +1000 分 if (f[i][20].shuzi==13) //全H { sum[i]+=200; if (f[i][18].shuzi==1 \u0026amp;\u0026amp; f[i][19].shuzi==1) sum[i]+=500; else if (f[i][18].shuzi==1) sum[i]-=100; else if (f[i][17].shuzi==1) sum[i]+=100; } else for (int j=1;j\u0026lt;=n;j++) //普通牌 if (f[i][j].fl==\u0026#39;H\u0026#39;) sum[i]+=shuzilue[f[i][j].shuzi]; else if (f[i][j].fl==\u0026#39;S\u0026#39;) sum[i]+=shuzilue[14]; else if (f[i][j].fl==\u0026#39;D\u0026#39;) sum[i]+=shuzilue[15]; if (n==1 \u0026amp;\u0026amp; f[i][17].shuzi==1) sum[i]=50;//只有1张牌且是C牌 else if (f[i][17].shuzi==1) sum[i]*=2;//不只1张牌但是有C牌 } if (flag) return 0;\t//4个都是0 for (int i=1;i\u0026lt;=4;i++) if (sum[i]\u0026gt;0) printf(\u0026#34;+%d \u0026#34;,sum[i]); else printf(\u0026#34;%d \u0026#34;,sum[i]); printf(\u0026#34;\\n\u0026#34;); } return 0; } D.数字口袋 只要注意不要超过sum的最大值就好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { long long n; cin\u0026gt;\u0026gt;n; long long sum=0; long long i=1; while(sum\u0026lt;n){ sum=sum+i; if(sum\u0026lt;=n){//一定要有这判断哇 cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; } i++; } return 0; } E\\F狠狠地切割(Easy\\hard Version) esay版本有两种解法，离散和二分，hard直接二分。 easy:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;bits/stdc++.h\u0026gt; #define N 5000006 using namespace std; int a[N],b[N],c[N]; bool iscut[N]; int main() { ios::sync_with_stdio(false); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=m;i++) cin\u0026gt;\u0026gt;b[i]; for(int i=1;i\u0026lt;=m;i++) c[b[i]]=1;\t//将b的值保存在c中 for(int i=1;i\u0026lt;=n;i++) if(c[a[i]]) iscut[i]=true;\t//如果a中的值等于b，此点为割点，将下标值标记为true iscut[0]=true;\t//a的头也是割点 int cnt=0; for(int i=1;i\u0026lt;=n;i++) if(!iscut[i]\u0026amp;\u0026amp;iscut[i-1]) cnt++; cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; return 0; } hard:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;long long\u0026gt;a,b; int n,m; bool check(long long k) { long long l=0,r=m-1,mid; while(l\u0026lt;=r){ mid=(l+r)\u0026gt;\u0026gt;1; if(k\u0026gt;b[mid]) l=mid+1; else if(k\u0026lt;b[mid]) r=mid-1; else return true;\t//找到 } return false;\t//找不到 } int main() {\tios::sync_with_stdio(false); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; long long x,y; for(long long i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;x,a.push_back(x); for(long long i=0;i\u0026lt;m;i++) cin\u0026gt;\u0026gt;y,b.push_back(y); sort(b.begin(),b.end());\t//vector的迭代器 long long ans=0; if(!check(a[0]))\t//第一个数据不是断点，说明是个片段 ans++; for(long long i=1;i\u0026lt;n;i++){ if(!check(a[i])\u0026amp;\u0026amp;check(a[i-1]))\t//这个数据不是断点，但是前一个数据是断点 ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } hard不用stl容器写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;bits/stdc++.h\u0026gt; #define N 5000006 using namespace std; int a[N],b[N],c[N]; bool iscut[N]; int main() { ios::sync_with_stdio(false); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i]; for(int i=1;i\u0026lt;=m;i++) cin\u0026gt;\u0026gt;b[i]; for(int i=1;i\u0026lt;=m;i++) c[b[i]]=1;\t//将b的值保存在c中 for(int i=1;i\u0026lt;=n;i++) if(c[a[i]]) iscut[i]=true;\t//如果a中的值等于b，此点为割点，将下标值标记为true iscut[0]=true;\t//a的头也是割点 int cnt=0; for(int i=1;i\u0026lt;=n;i++) if(!iscut[i]\u0026amp;\u0026amp;iscut[i-1]) cnt++; cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; return 0; } 另外，我发现stl可以快速解决去重的问题：\nvectoralls; //存储所有待离散化的值 sort(alls.begin(),alls.end()); //将所有值排序 alls.erase(unique(alls.begin(),alls.end()),alls.end()); //去掉重复元素\n其中unique的作用时将所有重复元素放在数组的后面，并返回重复元素之前的最后一个数组下标，之后erase掉后面的重复元素就ok\nG.如何得到npy emmm实在是不好意思，写这题的时候我还不会图论和dfs，因此我不打算解这题，我把关于图论和dfs的知识先了解一波。 dfs代码： dfs进行全排列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //DFS入门小题：打印全排列 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=10000005; int path[N];//存路径 bool st[N];//存状态 int n;//1~n的全排列 void dfs(int u){ if(u==n){ for(int i=0;i\u0026lt;n;i++) printf(\u0026#34;%d \u0026#34;,path[i]); cout\u0026lt;\u0026lt;endl; } else{ for(int i=1;i\u0026lt;=n;i++){ if(!st[i]){\t//没有记录过i path[u]=i;\t//记录u这个位置可放的数 st[i]=true;\t//标记i被记录 dfs(u+1);//进入下一层 st[i]=false; //在这一层恢复现场 } } }\t} int main() { cin\u0026gt;\u0026gt;n; dfs(0);//从0开始 return 0; } H.做不完的作业 有n个任务，每个有时间ti\nEric 前 i天要睡rxi小时，每天至少睡1小时，每天只能在做完所做的任务后睡觉。 问至少需要多少天才能完成任务。\n那么我们可以 O(1) 求出完成这个任务需要先睡多少天，再完成任务即可\n乐，，我还是没搞懂，直接复制大佬的代码，哭辽~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; long long n,x,p,q,i=1,sum,t,w; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;x\u0026gt;\u0026gt;p\u0026gt;\u0026gt;q; while(n--){ cin\u0026gt;\u0026gt;w; if((x-t-w+sum)*q\u0026gt;=i*p*x\u0026amp;\u0026amp;x-t\u0026gt;w)t+=w; else{ sum+=x-t; i++; long long l=ceil((q*(sum+x-w)-p*i*x)*1.0/(x*p-x*q)); if(l\u0026gt;0){ sum+=x*l; i+=l; } t=w; } } cout\u0026lt;\u0026lt;i; } I.毕业后 见代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; //E每个学生最多拿到一个 //最大比例 ,向下取整floor() int main() { double a,b;\t//a科目，b人数 cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; double w; w=1.0/a; //a种科目有一个为E的概率为1.0/a w=floor(w*b)/b; //b学生中有一个科目为E的学生人数/b学生总人数 printf(\u0026#34;%.16lf\u0026#34;,w); return 0; } J.旋转排列 将 p 里的每一个数字都依次向后移动一位，并把 p 的最后一个数字移动到开头去。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt;a; int main() { int n; cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;n;i++){ int x; cin\u0026gt;\u0026gt;x; a.push_back(x); } while(1){ a.insert(a.begin(),a[n-1]);//头部插入 a.pop_back();\t//尾部删除 for(int i=0;i\u0026lt;n;i++){ cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; if(a[n-1]==n){ break; } } return 0; } K.标题计数 数题解中有多少个一级标题\n若一行的第一个非空白字符是井号（#），且紧跟着若干个空格，则这一行剩余的非空白内容将会按照一级标题渲染。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,pos; int main(){ cin\u0026gt;\u0026gt;n; cin.get(); while(n--){ char a[1000]; fgets(a,1000,stdin); //读入一行数据 int f=0; for(int i=0;a[i+1]!=\u0026#39;\\0\u0026#39;;i++){ if(f==1\u0026amp;\u0026amp;a[i]!=\u0026#39; \u0026#39;){ pos++; //一级标题个数+1 break; }//可能有首字符是空格的情况 if(a[i]!=\u0026#39;#\u0026#39;\u0026amp;\u0026amp;a[i]!=\u0026#39; \u0026#39;) //不是一级标题，直接break break; if(a[i]==\u0026#39;#\u0026#39;){ //判断是不是一级标题 if(a[i+1]==\u0026#39; \u0026#39;) f=1; //是标记为true else break; //不是直接break } } } cout\u0026lt;\u0026lt;pos; return 0; } Day4 补题 用数组实现链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 100010; // e[i] 表示节点i的值 // ne[i] 表示节点i的next指针是多少 // cur 存储当前已经用到了哪个点 int cur=1,e[N],ne[N]; //注意：头结点为cur=0 void add_k(int k, int x)\t//将x插到第k个插入的元素后面 { e[cur]=x;\t//将x值存入head之后的结点 ne[cur]=ne[k];\t//将x结点指向k结点的下一个结点 ne[k]=cur;\t//将k结点的下一个结点指向x结点 cur++;\t//cur变到下一个位置 } void del_k(int k)\t//删除第k个插入的元素后面的数 { ne[k] = ne[ne[k]];\t//k的下一个结点，指向k下一个结点的下一个结点。 //即掠过k的下一个结点 } int main() { int m; cin \u0026gt;\u0026gt; m; while (m--) {\t//m组测试用例 char op; int k,x; cin \u0026gt;\u0026gt; op; if (op == \u0026#39;H\u0026#39;) { //特殊判断，H的时候头结点cur=0 cin \u0026gt;\u0026gt; x; add_k(0,x); } else if (op == \u0026#39;I\u0026#39;) {\t//\t执行insert操作 cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add_k(k,x); } else { cin \u0026gt;\u0026gt; k; del_k(k); } } for (int j = ne[0]; j ; j = ne[j]) cout \u0026lt;\u0026lt; e[j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; return 0; } Day5 SMU Winter 2023 Round #2 (Div.2) A Medium Number 给三个数求中位数 1.可以排序之后取中间值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int a[5]; int main() { int t; cin\u0026gt;\u0026gt;t; while(t--) { memset(a,0,sizeof(a)); for(int i=0;i\u0026lt;3;i++) cin\u0026gt;\u0026gt;a[i]; sort(a,a+3); cout\u0026lt;\u0026lt;a[1]\u0026lt;\u0026lt;endl; } return 0; } 2.也可以直接无脑找出中间值、\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t, a, b, c; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c) != EOF) { if (a \u0026gt; b) { t = a; //b\u0026gt;a a = b; b = t; } if (a \u0026gt; c)//c\u0026gt;a { t = a; a = c; c = t; } if (b \u0026gt; c)//c\u0026gt;b { t = b; b = c; c = t; } printf(\u0026#34;%d\\n\u0026#34;, b); } return 0; } B Yes-Yes? 用c++的stl寻找字串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s1; int main(void) { int t; cin \u0026gt;\u0026gt; t; while(t--) { string s = \u0026#34;YesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYesYes\u0026#34;; cin \u0026gt;\u0026gt; s1; if(s.find(s1)!=-1) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else\tcout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } C.Atilla\u0026rsquo;s Favorite Problem 字符以\u0026rsquo;\\0\u0026rsquo;为结束标志 特别记住： 小写字母-\u0026lsquo;a\u0026rsquo;=0~25 方法一：C风格的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t,n,max; scanf(\u0026#34;%d \u0026#34;,\u0026amp;t); while(t--) { max = 0; scanf(\u0026#34;%d \u0026#34;, \u0026amp;n); int c; while ((c=getchar())!= \u0026#39;\\n\u0026#39;) //用\u0026#39;\\0\u0026#39;就用担心找不到结尾 { if (max\u0026lt; c- \u0026#39;a\u0026#39; + 1) { max= c- \u0026#39;a\u0026#39; + 1; } } printf(\u0026#34;%d\\n\u0026#34;, max); } return 0; } 方法二：C++风格的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t,n,max; scanf(\u0026#34;%d \u0026#34;,\u0026amp;t); while(t--) { max=0; scanf(\u0026#34;%d \u0026#34;,\u0026amp;n); string s; int a[100005]; cin\u0026gt;\u0026gt;s;\t//读入字符串 for(int i=0;i\u0026lt;s.size();i++) a[i]=s.at(i)-\u0026#39;a\u0026#39;+1; //将字符串化成的数组赋值给整型数组 sort(a,a+s.size(),greater\u0026lt;int\u0026gt;()); //排序找最大的 printf(\u0026#34;%d\\n\u0026#34;,a[0]); //输出最大 } return 0; } D.Lost Permutation 全排列，先想到暴力bf 1.暴力的时候慢慢加都超过和，肯定不行 2.暴力完之后检查一遍，如果前面暴力枚举的数没有达到m+res个数，也就是说暴力枚举得到的数列个数不够，那也是没有完成全排列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include\u0026lt;bits/stdc++.h\u0026gt; #define N 110 typedef long long ll; using namespace std; bool b[N]; int main(void) { int t; cin \u0026gt;\u0026gt; t; while(t--) { memset(b,0,sizeof(b)); ll m,s; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; for(int i=1;i\u0026lt;=m;i++) { int num; cin \u0026gt;\u0026gt; num; b[num] = 1;\t//离散化 } ll sum=0; int flag=0; int res=0; for(int i=1;i\u0026lt;=N;i++)\t//bf { if(!b[i])\t//当没有i这个数时 { sum+=i; res++;\t//记录bf添加多少个数 b[i] = 1; } if(sum==s)\t//正好等于和 { break; } else if(sum\u0026gt;s)\t//大于和慢慢累加都不行你没救了 { flag=1; break; } } for(int i=1;i\u0026lt;=m+res;i++) { if(!b[i])\t//遍历一遍全排所有元素,看看是不是全排列 { flag=1;\t//如果有一个没有被1的元素混入，说明前面bf没有枚举到他就已经超了或者等于s break; } } if(!flag) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt;endl; } return 0; } E.Challenging Valleys 有坑点 1.只能有一个波谷，刚开始我以为题目判断的是有没有波谷，于是wrong on test 2 于是，我只能转换思路，判断是否只有一个波谷。 2.但是，没想到中间会有想通过的元素，于是判断左右两边是否存在波谷就显得蛮烦。 于是，当元素相同的时候直接把指针移向相同元素的后一位。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; long long a[200005]; int main(void) { int t; cin \u0026gt;\u0026gt; t; while(t--) { int n; cin \u0026gt;\u0026gt; n; for(int i=1;i\u0026lt;=n;i++) { cin \u0026gt;\u0026gt; a[i]; } int cnt=0; int l=1,r=1;//刚开始l和r相等 a[0] = 1e9+10;\t//为了不越界多围一圈 a[n+1] = 1e9+10;\t//左右边界一定满足，不论大小 for(int i=1;i\u0026lt;=n;i++) { //如果满足l小于左边，r小于右边，则是山谷，cnt++即可 if(a[l]\u0026lt;a[l-1]\u0026amp;\u0026amp;a[r]\u0026lt;a[r+1]) { l = r+1; r = l; cnt++; continue; } //如果r跟r+1相等,则证明它们是相同元素，所以r++ if(a[r]==a[r+1]) { r++; continue; } //保证左右仍然相等 l = r+1; r = l; } if(cnt==1) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } F.Binary Inversions 本题只能改变一次：You are allowed to perform one operation on it at most once. 为了使0前面的1最多。 有两种改法： 1.将最前面的0改成1 2.将最后面的1改成0 本题还有一个坑点，也许改过之后的0前面的1不如不改的情况，所以要记得比较不改的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include\u0026lt;bits/stdc++.h\u0026gt; typedef long long ll; using namespace std; const int N = 2e5+10; ll a[N],b[N],c[N]; int main(void) { int t; cin \u0026gt;\u0026gt; t; while(t--) { int n; cin \u0026gt;\u0026gt; n; for(int i=1;i\u0026lt;=n;i++) { cin \u0026gt;\u0026gt; a[i]; b[i] = a[i]; c[i] = a[i]; } ll res=0; for(int i=1;i\u0026lt;=n;i++) { if(a[i]==0)\t//0变成1 { a[i] = 1; break; } } ll sum1=0,c1=0; for(int i=1;i\u0026lt;=n;i++) { if(a[i])\t//每个0前的1有几个 { c1++; } else { sum1 += c1;//将第一个0改成1的sum } } res = max(res,sum1); for(int i=n;i\u0026gt;=1;i--) { if(b[i])\t//1改为0 { b[i] = 0; break; } } sum1=0,c1=0; for(int i=1;i\u0026lt;=n;i++) { if(b[i]) { c1++;\t//复制粘贴 } else { sum1 += c1; } } res = max(sum1,res); sum1=0; c1 = 0; for(int i=1;i\u0026lt;=n;i++) { if(c[i])\t//不变 { c1++; } else { sum1 += c1; } } res = max(sum1,res); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } return 0; } G.Quests 规则是这样的，你回答问题，你可以得到奖励，但是不能在k天内继续回答同一个问题。\n1.如果某一天最大的奖励大于c。说明k无论取何值，都能满足奖励大于c-\u0026gt;输出Infinity\n2.如果所有天的最大奖励加起来都不大于c。说明k无论取何值，都不会满足奖励大于c-\u0026gt;Impossible\n3.用二分的方法，找出k。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long ll arr[200005]; bool check(int mid, ll c, int d, int n){ ll sum = arr[0]; for(int i = 1; i \u0026lt;= mid \u0026amp;\u0026amp; i\u0026lt;min(d,n); i++){ sum += arr[i]; } ll ans = d / (mid + 1);\t//运用倍数关系，直接将前面的循环步骤省略 int cnt = d % (mid + 1); sum *= ans; for(int i = 0; i \u0026lt; cnt \u0026amp;\u0026amp; i \u0026lt; n; i++){ sum += arr[i]; } if(sum \u0026gt;= c){ return true; } return false; } int main(){ int t; cin \u0026gt;\u0026gt; t; while(t--){ int n; ll c; int d; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; for(int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; arr[i]; } sort(arr, arr + n, greater\u0026lt;ll\u0026gt;()); ll sum = 0; for(int i = 0; i \u0026lt; min(n, d); i++){ sum += arr[i]; } if(sum \u0026gt;= c){ cout \u0026lt;\u0026lt; \u0026#34;Infinity\u0026#34; \u0026lt;\u0026lt; endl; continue; } if(arr[0] * d \u0026lt; c){ cout \u0026lt;\u0026lt; \u0026#34;Impossible\u0026#34; \u0026lt;\u0026lt; endl; continue; } int l = 0, r = max(d,n); while(l \u0026lt;= r){ int mid = (l + r) / 2; if(check(mid, c, d, n)){ l = mid + 1; }else{ r = mid - 1; } } cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl;\t//输出哪一边都ok } return 0; } H.SlavicG\u0026rsquo;s Favorite Problem emm由于dfs是真的不会，只能先放下这题去学深搜。。于是就把大佬的代码放上来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; p[100050]; int n,a,b; int f = 0; int dis[100050]; int vis[100050]; int dis1[100050]; int vis1[100050]; map\u0026lt;int,int\u0026gt; rr,ll; void bfs() { queue\u0026lt;int\u0026gt; q; q.push(a); dis[a] = 0; while(q.size()) { auto ver = q.front(); q.pop(); if(vis[ver]) continue; vis[ver] = 1; for(int i = 0;i \u0026lt; p[ver].size();i++) { auto j = p[ver][i]; int ne = j.first; int ww = j.second; if(!vis[ne]) { if(ne != b) { dis[ne] = ww^dis[ver]; q.push(ne); } } } } } void bfs1() { queue\u0026lt;int\u0026gt; q; q.push(b); dis1[b] = 0; while(q.size()) { auto ver = q.front(); q.pop(); if(vis1[ver]) continue; vis1[ver] = 1; for(int i = 0;i \u0026lt; p[ver].size();i++) { auto j = p[ver][i]; int ne = j.first; int ww = j.second; if(!vis1[ne]) { dis1[ne] = ww^dis1[ver]; rr[dis1[ne]] = 1; q.push(ne); } } } } void solve() { f = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt;b; rr.clear(); ll.clear(); for(int i = 1;i \u0026lt;= n;i++) { p[i].clear(); vis[i] = 0; dis[i] = 0; vis1[i] = 0; dis1[i] = 0; } for(int i = 1;i \u0026lt; n;i++) { int l,r,w; cin \u0026gt;\u0026gt; l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;w; p[l].push_back({r,w}); p[r].push_back({l,w}); } bfs(); bfs1(); for(int i = 1;i \u0026lt;= n;i++) { if(rr[dis[i]]) { cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; return ; } } cout\u0026lt;\u0026lt;\u0026#34;NO\\n\u0026#34;; } signed main() { int t = 1; cin \u0026gt;\u0026gt; t; while(t--) { solve(); } } I.The Humanoid 怪兽的血量越多越难吸收，所以要先从血量小的开始吸收，如果一个怪兽开始不可以被吸收了，后面的大血量怪兽都不可以被吸收。\n我们可以发现一共就三瓶药,两种,我们把所有喝药的顺序情况枚举出来,找最大值即可 一、3,2,2 二、2,3,2 三、2,2,3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; long long a[200500]; void solve() { long long n,hh; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; hh; for(int i = 0;i \u0026lt; n;i++) cin \u0026gt;\u0026gt; a[i]; sort(a,a+n);\t//排序找最弱的人 int ans = 0; //k=0,up=0 3,2,2 //k=1,up=0 2,3,2 //k=2,up=0 2,2,3 for(int k = 0;k \u0026lt;3;k++) { int up = 0; int i = 0; long long h = hh;\twhile(i \u0026lt; n) { if(h \u0026gt; a[i])\t//h的血量大于人的血量 { h += a[i]/2;\t//只能提升a[i]/2 i++; } else if(up == 3) { break; } else { if(up == k) { h = h*3; } else { h = h*2; } up++; } } ans = max(ans,i);\t//吸收最多的人 } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; } int main() { int t = 1; cin \u0026gt;\u0026gt; t; while(t--) { solve(); } } J.Make It Round 给定n,m,我们可以把n变为n×k（1\u0026lt;=k\u0026lt;=m,k为正整数)，如果存在，请输出末尾0的个数最多的n×k，否则输出n×m。 为了出现0，我们需要有10，也就是2×5。 有几个0就是有多少个2×5\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; char a[105][105]; void solve() { long long n,m; cin \u0026gt;\u0026gt;n \u0026gt;\u0026gt; m; int cnt2 = 0,cnt5 = 0;//记录5的个数和2的个数 int k = n; while(k%2 == 0)\t//记录2的个数 { cnt2 ++; k = k/2; } while(k%5 == 0)\t//记录5的个数 { cnt5 ++; k = k /5; } while(cnt5 \u0026gt; cnt2\u0026amp;\u0026amp; m/2) //5的个数\u0026gt;2的个数，想办法在[1,m]中搞出2，凑成10 { cnt5--; n*=2; m/=2; } while(cnt2 \u0026gt; cnt5\u0026amp;\u0026amp; m/5)//同理 { cnt2--; n *=5; m/=5; } long long ans = 1; while(ans*10 \u0026lt;= m)//找10的数目，找到不能找为止,当然,最后虽然可能不为10 { ans = ans*10; } ans = m/ans*ans; cout\u0026lt;\u0026lt;ans*n\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; //新的n已经保证为圆润的数了 } int main() { int t = 1; cin \u0026gt;\u0026gt; t; while(t--) { solve(); } } K.Thermostat 见代码： 分三种情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;bits/stdc++.h\u0026gt; #define int long long using namespace std; int t; int l,r; int x,a,b; signed main() { cin\u0026gt;\u0026gt;t; while(t--) { int k=5; //k不会大于3 cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;x\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(a==b)\t//相同不用改变 { cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; continue; } if(abs(a-b)\u0026gt;=x)\t//ab距离已经大于x，直接移到b { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; continue; } if(abs(l-b)\u0026lt;x\u0026amp;\u0026amp;abs(r-b)\u0026lt;x) //b这个位置不能由两头到达，a不管怎么移动都到不了b { cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; continue; } if(abs(l-a)\u0026gt;=x\u0026amp;\u0026amp;abs(l-b)\u0026gt;=x){ k=2; } else{ k=3; } if(abs(r-a)\u0026gt;=x\u0026amp;\u0026amp;abs(r-b)\u0026gt;=x){ k=2; } else{ k=k\u0026lt;3?k:3; }\tif(k\u0026gt;3) { cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;k\u0026lt;\u0026lt;endl; } } return 0; } L.Advantage 1.如果不是最大值，那就只能减去第最大 2.如果使最大值，那就减去第二大\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; int main() { ll t; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;t); while(t--){ vector\u0026lt;ll\u0026gt;a,b; ll n; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); for(ll i=0;i\u0026lt;n;i++){ ll x; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;x); a.push_back(x); b.push_back(x); } sort(a.begin(),a.end(),greater\u0026lt;ll\u0026gt;()); for(ll i=0;i\u0026lt;n;i++){ if(b[i]!=a[0])\t//不等于最大值，做差 printf(\u0026#34;%d \u0026#34;,b[i]-a[0]); else printf(\u0026#34;%d \u0026#34;,b[i]-a[1]);//等于，减倒数第二大的 } printf(\u0026#34;\\n\u0026#34;); } } ","date":"2023-01-08T17:05:19+08:00","permalink":"https://IsQinna.github.io/p/2023%E5%AF%92%E5%81%87%E8%AE%AD%E7%BB%83week0acm%E9%9B%86%E8%AE%AD/","title":"2023寒假训练week0（ACM集训）"}]